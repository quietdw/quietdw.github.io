<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>4种常用Linux命令用法</title>
    <url>/2018/10/11/4%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li>语法：<code>ls [选项参数] [目录或者目录名]</code></li>
<li>常用选项参数：<ul>
<li><code>-a</code>：显示所有的文件，包括隐藏文件(以.开头的文件)，参考示例 1</li>
<li><code>-d</code>：仅列出目录本身，而不是列出目录里的内容列</li>
<li><code>-l</code>：列出长数据串，显示出文件的属性与权限等数据信息</li>
<li><code>-h</code>：将文件内容大小以 GB、KB 等易读的方式显示</li>
</ul>
</li>
<li>全部选项参数：<a href="https://explainshell.com/explain/1/ls">https://explainshell.com/explain/1/ls</a></li>
</ul>
<span id="more"></span>

<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><ul>
<li>语法：<code>cat [选项] [文件]</code></li>
<li>cat 主要有三大功能:<ul>
<li>一次显示整个文件：<code>cat filename</code></li>
<li>创建一个新文件：<code>car &gt; filename</code></li>
<li>将几个文件合并成为一个文件：<code>cat file1 file2 &gt; filename</code></li>
</ul>
</li>
<li>常用选项参数：<ul>
<li><code>-n</code>：由 1 开始对所有输出的行数编号</li>
<li><code>-b</code>：和<code>-n</code>相似，只不过对于空白行不编号</li>
<li><code>-s</code>：当遇到有连续两行以上的空白行，就代换为一行的空白行</li>
<li><code>-v</code>：使用<code>^</code>和<code>M-</code>符号，除了 LFD 和 TAB 之外</li>
<li><code>-E</code>：在每行结束处显示<code>$</code></li>
<li><code>-T</code>：将 TAB 字符显示为<code>^I</code></li>
</ul>
</li>
<li>cat 命令详解：<a href="https://www.cnblogs.com/zhangchengxiang/p/5195583.html">https://www.cnblogs.com/zhangchengxiang/p/5195583.html</a></li>
</ul>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><ul>
<li><p>语法：<code>mv [选项] 源文件或目录 目标文件或目录</code></p>
<table>
<thead>
<tr>
<th>命令格式</th>
<th>运行结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>mv 文件名1 文件名2</code></td>
<td>将文件名 1 重命名为文件名 2</td>
</tr>
<tr>
<td><code>mv 文件名 目录名</code></td>
<td>将文件移动到目标目录</td>
</tr>
<tr>
<td><code>mv 目录名1 目录名2</code></td>
<td>目录 1 已存在，将目录 1 移动到目录 2；目录 2 不存在则改名</td>
</tr>
</tbody></table>
</li>
<li><p>常用选项参数</p>
<ul>
<li><code>-i</code>：若目标文件已经存在时，就会询问是否覆盖</li>
<li><code>-f</code>：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li>
</ul>
</li>
<li><p>全部选项参数：<a href="https://explainshell.com/explain/1/mv">https://explainshell.com/explain/1/mv</a></p>
</li>
</ul>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><ul>
<li>语法：<code>touch [选项] [文件或者目录]</code><ul>
<li>命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件</li>
</ul>
</li>
<li>全部选项参数：<a href="https://explainshell.com/explain/1/touch">https://explainshell.com/explain/1/touch</a></li>
</ul>
<blockquote>
<p>注：命令行解释工具<a href="explainshell.com">explainshell.com</a>是一个帮助你解释命令行的网站，它会分析命令的帮助文档，然后根据你想查询的命令参数来抽取对应的解释，然后简洁易懂地显示出来，在国内访问受限。</p>
</blockquote>
]]></content>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>堆叠上下文</title>
    <url>/2018/11/04/CSS%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h3 id="什么是堆叠上下文"><a href="#什么是堆叠上下文" class="headerlink" title="什么是堆叠上下文"></a>什么是堆叠上下文</h3><p>层叠上下文，英文称作 ”stacking context” 。是 HTML 中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素（包括其中的子元素）在 z 轴上就“高人一等”。</p>
<span id="more"></span>

<p><img src="https://jiangnana.fun/test/%E5%A0%86%E5%8F%A0%E9%A1%BA%E5%BA%8F.jpg" alt="堆叠顺序"></p>
<h3 id="什么时候出现堆叠上下文？"><a href="#什么时候出现堆叠上下文？" class="headerlink" title="什么时候出现堆叠上下文？"></a>什么时候出现堆叠上下文？</h3><p>堆叠上下文可以理解为堆叠作用域，以下属性会出发堆叠上下文。</p>
<ul>
<li>根元素(HTML)</li>
<li>z-index 值不为 auto 的，相对绝对定位</li>
<li>z-index 值不为 auto，flex 项目，即父元素 display:flex/inline-flex</li>
<li>opacity 的值小于 1 的元素，rgba 不算，这是背景</li>
<li>transform 属性不为 none</li>
<li>mix-blend-mode 属性不为 normal 的元素</li>
<li>filter 的值不为 none 的元素</li>
<li>perspective 的值不为 none 的元素</li>
<li>isolation 属性被设置为 isolate 的元素</li>
<li>position: fixed</li>
<li>在 will-charge 中指定了任意 css 属性</li>
<li>webkit-overflow-scrolling 属性被设置 touch 的元素</li>
</ul>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/</a></li>
</ul>
]]></content>
      <tags>
        <tag>堆叠上下文</tag>
        <tag>z-index</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS实现图片加载前占位</title>
    <url>/2019/04/11/CSS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%89%8D%E5%8D%A0%E4%BD%8D/</url>
    <content><![CDATA[<p>在优化个人简历网站的时候，发现图片加载很慢，页面结构异常，故通过提前占位的方式使页面结构能保持正常</p>
<span id="more"></span>

<p>基本思路是利用图片的比例，给父元素加一个 padding-top，代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">100%</span>; //假设图片比例<span class="number">1</span>:<span class="number">1</span>，则是<span class="number">100%</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局</title>
    <url>/2018/10/23/CSS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h3><ol>
<li>绝对定位布局<ul>
<li>在父元素下设置两个宽度 50%容器，设置绝对定位。但有时候会出错。</li>
<li>父容器不得不必须要设置高度，但设置高度会出 bug（内容改变的时候），更不要说绝对定位的元素脱离了文档流。</li>
</ul>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>Table 布局<br>使用<code>display: table</code>使父亲元素变成一个 table，然后使用<code>display: table-cell</code>使子元素变成里面的元素。</p>
</li>
<li><p>浮动布局<br>使用 float 布局，可以解决绝对定位带来问题。此外父元素要清除浮动，以避免浮动带来高度塌陷的问题。</p>
</li>
<li><p>Flex 布局</p>
<ul>
<li>flex 布局非常棒，但是它仅限用于 ie10 以上的浏览器。</li>
<li>首先把父容器设置<code>display:flex</code>，为了使子元素都一样，子元素设置<code>flex:1</code>，不用设置宽高，完美。</li>
</ul>
</li>
</ol>
<blockquote>
<p>以上参考：</p>
</blockquote>
<ul>
<li><a href="https://css-tricks.com/left-and-right/">https://css-tricks.com/left-and-right/</a></li>
<li><a href="https://segmentfault.com/a/1190000011358507">https://segmentfault.com/a/1190000011358507</a></li>
</ul>
<h3 id="左中右布局"><a href="#左中右布局" class="headerlink" title="左中右布局"></a>左中右布局</h3><ol>
<li><p>Table 布局<br>和左右布局类似，再多加一列，只是不能优先显示中间的一列。</p>
</li>
<li><p>双飞翼布局</p>
<ul>
<li>在 HTML 布局中，center 放在最前面，其次 left，最后是 right，因此优先显示 center；</li>
<li>center，left，right 都设置<code>float:left</code>;</li>
<li>center 设置宽度 100%，此时 center 占满一行，left 和 right 都被挤到第二行；</li>
<li>此时给 left 设置<code>margin-left:100%</code>,left 就被拉倒最左边，同理 right 设置<code>margin-lef: 300px</code>（right 的宽度），拉到最右侧；</li>
<li>此时 center 的左右两边的内容被覆盖，给 center 加一个子元素 div，设置 margin，左右值分别为 left 和 right 的宽度； -浮动布局要给父元素清除浮动，或者添加属性<code>over-flow:hidden</code></li>
</ul>
</li>
<li><p>flex 布局</p>
<ul>
<li>给 container 设置<code>display: flex</code>；</li>
<li>center 设置宽度<code>width:100%</code>，left 和 right 设置；</li>
<li>给 left 和 right 设置<code>flex-shrink: 0</code>，使之不会收缩；</li>
<li>使用 order 属性给三个 div 重新排序，left 设置<code>order:1</code>，center 设置<code>order:2</code>，right 设置<code>order:3</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>以上参考：</p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/imwtr/p/4441741.html">https://www.cnblogs.com/imwtr/p/4441741.html</a></li>
<li><a href="https://www.jianshu.com/p/3046eb050664">https://www.jianshu.com/p/3046eb050664</a></li>
</ul>
<h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol>
<li><p>行内元素<br>对于<code>&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、&lt;em&gt;、&lt;img&gt;</code>这种内联元素，直接构建一个样式是<code>text-align:center</code>的容器。如果是块级元素，里面的文本会居中。</p>
</li>
<li><p>块级元素</p>
<ul>
<li><p>定宽</p>
<ul>
<li>添加样式<code>margin:0 auto</code>实现容器居中，<code>text-align:center</code>实现里面的文本居中;</li>
<li>设置绝对定位 50%，<code>margin:left：宽度的一半</code>；</li>
</ul>
</li>
<li><p>不定宽</p>
<ul>
<li>CSS3 的 flex 实现水平居中，父元素设置：<code>display：flex</code>，子元素设置<code>margin:auto</code>；</li>
<li>绝对定位 + transform，<code>transform: translateX(-50%)</code>可以移动本身元素的 50%；</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>以上参考</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/dengdongxia/article/details/80297116">https://blog.csdn.net/dengdongxia/article/details/80297116</a></li>
<li><a href="https://blog.csdn.net/MrZZhou/article/details/70344947">https://blog.csdn.net/MrZZhou/article/details/70344947</a></li>
</ul>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol>
<li><p>先试试<code>padding:20px 0;</code>再说</p>
</li>
<li><p>单行文本</p>
<ul>
<li>若元素是单行文本, 则可设置 line-height 等于父元素高度</li>
</ul>
</li>
<li><p>行内块级元素</p>
<ul>
<li>基本思想是使用 display: inline-block，vertical-align: middle 和一个伪元素让内容块处于容器中央。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>元素高度不定<br>使用 flex，父元素做如下设置即可保证子元素垂直居中:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>以上参考</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/MrZZhou/article/details/70344947">https://blog.csdn.net/MrZZhou/article/details/70344947</a></li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出</title>
    <url>/2018/11/19/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
    <content><![CDATA[<p>以前在用 CSS 时，总想系统学习一下 CSS 知识。因为以前写 CSS 时，总是哪里不会 baidu 哪里，没有系统性，对一些“效果”（bug）也是浅尝辄止，属于解决完就忘了的那种。现系统学习一番后，将学习总结、体会汇成一篇博客。</p>
<span id="more"></span>

<h1 id="CSS-不正交"><a href="#CSS-不正交" class="headerlink" title="CSS 不正交"></a>CSS 不正交</h1><p>CSS 易学，只要记住定义元素的属性和值就可以了，但因其不正交的特点，又使得它又非常难学。何为不正交？举个例子：当我们在页面中增加<code>u&gt;li</code>标签，其默认样式是有小圆点的，但是当我们给<code>li</code>加上<code>display:block</code>时，小圆点非常奇怪的消失了，这使得我们在使用 CSS 非常小心，因为你也不知道什么时候会踩坑。除此之外，还有以下几个坑：</p>
<ul>
<li><p>margin 与 border</p>
<ol>
<li><p>上下两个 div，margin 都为 10px 上 div 底部与下 div 顶部的 margin 会重合，有以下解决方法：</p>
<ul>
<li>在两个 div 之间加个 border 为 0.1px 的 div</li>
<li>给两个 div 之间加<code>display：table</code>的 div</li>
<li>给两个 div 之间加<code>display：flex</code>的 div</li>
<li>给两个 div 之间加<code>overflow: hidden;</code>的 div</li>
</ul>
</li>
<li><p>两个父子 div，子元素有 margin 值，子元素的 margin 值会超出父元素，有以下解决方法：</p>
<ul>
<li>给父元素加 border</li>
<li>给父元素加 padding</li>
<li>给父元素加<code>overflow: hidden;</code></li>
<li>给父元素加<code>display：flex</code>，子元素宽度会有变化</li>
</ul>
</li>
</ol>
</li>
<li><p><code>display:inline</code>、<code>display:inline-block</code>的元素，加了<code>position:absolute</code>，display 会变成 block;</p>
</li>
<li><p><code>display:fix</code>与 transform 混用，会影响 fix 的定位位置</p>
</li>
<li><p>float 与 inline 元素，inline 元素会环绕 float 元素，而不会在 float 元素下方，但是 block 元素会在下方</p>
</li>
</ul>
<h1 id="元素的宽高"><a href="#元素的宽高" class="headerlink" title="元素的宽高"></a>元素的宽高</h1><p>记住一点，能不用定死宽高的，就不要定死宽高，采用添加 padding 的方式撑高元素</p>
<ul>
<li>字与字通过基线对齐，元素高度相同，基线不同，并排的话，可能会导致撑开的高度大于元素本身。内联元素 margin 和 padding 会只会影响宽，不会影响高，其高度由 line-height 决定</li>
<li><code>font-size</code>的大小不一定真是字体大小，不同字体有默认行高（设计师设计时设置），使得不同字体的撑开的高度可能不一致</li>
<li>内联元素之间如果有空格，或有回车，在网页则会显示两个内联元素之间有一个莫名其妙的空格</li>
<li>设置了浮动，父元素要清除浮动，防止浮动造成高度塌陷</li>
<li>设置两端对齐<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.paernt</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: justify;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a href="https://jiangnana.fun/test/%E7%9C%81%E7%95%A5%E5%8F%B7.html">一行字，超出省略号</a></li>
<li><a href="https://jiangnana.fun/test/%E5%A4%9A%E8%A1%8C%E8%B6%85%E5%87%BA%E7%9C%81%E7%95%A5%E5%8F%B7.html">多行字超出省略号（管 IE 干嘛 →_→）</a></li>
</ul>
<h1 id="堆叠上下文"><a href="#堆叠上下文" class="headerlink" title="堆叠上下文"></a>堆叠上下文</h1><p><a href="https://jiangnana.fun/2018/11/04/CSS%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/">开启传送门·另一篇博客</a></p>
<h1 id="icon-的做法"><a href="#icon-的做法" class="headerlink" title="icon 的做法"></a>icon 的做法</h1><p>现在使用较多的是通过 SVG 导入在线图标，也有通过背景图的（sprites 生成器），或者直接用 CSS 干的比如<a href="https://jiangnana.fun/test/taichi.html">太极图</a></p>
<h1 id="移动端页面"><a href="#移动端页面" class="headerlink" title="移动端页面"></a>移动端页面</h1><p>移动端的页面和 PC 端的没区别，但要注意以下几点</p>
<ul>
<li>手机端要加个<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code>禁止用户缩放</li>
<li>媒体查询，需要注意优先级问题，后面优先级强<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">980px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>&lt;link rel=&#39;stylesheet&#39; href=&#39;xxx.css&#39; media=&#39;max-width:375px&#39;&gt;</code>设备小于 320px 才引用 style.css</li>
<li>要设计图，没设计图不做</li>
<li>学会隐藏元素</li>
<li>手机端有 touch 事件，没有 hover 事件</li>
<li>手机端不能改变屏幕大小（resize），也没有滚动条</li>
</ul>
<h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><p>flex 适用于简单的线性布局，更复杂的用 grid</p>
<p>主要记住 flex container 以及 flex item 的六个属性</p>
<p>flex container</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>flex-direction</td>
<td>定义内部元素的排序方向，常用的有 row，row-reverse，column，column-reverse</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>是否换行</td>
</tr>
<tr>
<td>flex-flow</td>
<td>上面两个的简写</td>
</tr>
<tr>
<td>justify-content</td>
<td>主轴方向的对齐方向</td>
</tr>
<tr>
<td>align-items</td>
<td>侧轴方向的对齐方向</td>
</tr>
<tr>
<td>align-content</td>
<td>多行、多列内容的对齐方向，center，space-around，space-bteween 等</td>
</tr>
</tbody></table>
<p>flex item</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>flex-grow</td>
<td>空间有空余时，增长比例</td>
</tr>
<tr>
<td>flex-shrink</td>
<td>空间不够时，收缩比例</td>
</tr>
<tr>
<td>flex-basis</td>
<td>设置初始大小</td>
</tr>
<tr>
<td>flex</td>
<td>上面三个的缩写</td>
</tr>
<tr>
<td>order</td>
<td>元素排列顺序</td>
</tr>
<tr>
<td>align-self</td>
<td>自身的对齐方式，重写 align-items 的属性</td>
</tr>
</tbody></table>
<h1 id="BFC（格式化上下文）"><a href="#BFC（格式化上下文）" class="headerlink" title="BFC（格式化上下文）"></a>BFC（格式化上下文）</h1><p>什么是 BFC 说不清楚</p>
<p>但可以说明某例子是否是 BFC</p>
<p>一个块格式化上下文（block formatting context） 是 Web 页面的可视化 CSS 渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。</p>
<p>一个块格式化上下文由以下之一创建：</p>
<ul>
<li>根元素或其它包含它的元素</li>
<li>浮动元素 (元素的 float 不是 none)</li>
<li>绝对定位元素 (元素具有 position 为 absolute 或 fixed)</li>
<li>内联块 (元素具有 display: inline-block)</li>
<li>表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性)</li>
<li>表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性)</li>
<li>具有 overflow 且值不是 visible 的块元素，</li>
<li>display: flow-root</li>
<li>column-span: all 应当总是会创建一个新的格式化上下文，即便具有 - - column-span: all 的元素并不被包裹在一个多列容器中</li>
</ul>
<p>一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。</p>
<p>BFC 有什么用？ - 使父元素能包住子元素 - 兄弟之间划清界限</p>
<h1 id="动态-rem"><a href="#动态-rem" class="headerlink" title="动态 rem"></a>动态 rem</h1><p>em 是自己的 font-size 的值的大小，大概就是一个汉字的高度，或者一个字母 M 的高度</p>
<p>rem 是 root em ，指的是根元素（html）的字体大小</p>
<ul>
<li>可以通过 js 动态调整 rem 大小</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">     var pageWidth = window.innerWidth</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml">     document.write(&#x27;<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-tag">html</span>&#123;<span class="attribute">font-size</span>:<span class="string">&#x27;+pageWidth+&#x27;</span>px;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>&#x27;)</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="xml"> </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 SCSS 里使用 PX2REM<br>在 vscode 里可以下载 sass 插件</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> px(<span class="variable">$px</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$px</span>/<span class="variable">$designWidth</span> * <span class="number">10</span> + rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$designWidth</span>: <span class="number">640</span>; <span class="comment">// 640 是设计稿的宽度，你要根据设计稿的宽度填写。如果设计师的设计稿宽度不统一，就杀死设计师，换个新的。</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: px(<span class="number">320</span>);</span><br><span class="line">  <span class="attribute">height</span>: px(<span class="number">160</span>);</span><br><span class="line">  <span class="attribute">margin</span>: px(<span class="number">40</span>) px(<span class="number">40</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h1><p>2 兼容 IE6,3 不兼容 IE6</p>
<p>栅栏布局：</p>
<pre><code>- .row&gt;div.col-lg-12
- .row&gt;div.col-md-12
- .row&gt;div.col-xs-12
- .row&gt;div.col-sn-12
</code></pre>
<p>建议不要更改 bootstrap 上类的值，如需修改，建议套一个父级 div，在父级 div 上更改</p>
<p>其余的抄官方文档就完事了。。。</p>
<h1 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h1><p>BFC 的兄弟，指 inline formatting context</p>
<p><code>font-size：100px;</code>到底指的是什么呢？em-square，要去了解国外的活字印刷，指的是印刷这个字的模具大小。</p>
<p>line-height：实际占地高度</p>
<p><code>vertical-align</code>可以用来解决 img 元素在 div 中，底部有空隙的 bug，其余没什么用。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS知识点</title>
    <url>/2018/10/21/CSS%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="CSS-介绍"><a href="#CSS-介绍" class="headerlink" title="CSS 介绍"></a>CSS 介绍</h3><p>层叠样式表 (Cascading Style Sheets，缩写为 CSS），是一种 样式表语言，用来描述 HTML 或 XML（包括如 SVG、MathML、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。</p>
<span id="more"></span>

<p>CSS 是开放网络的核心语言之一，由 W3C 规范 实现跨浏览器的标准化。CSS 被分为不同等级：CSS1 现已废弃， CSS2.1 是推荐标准（修改了 CSS2 中部分错误）， CSS3 分成多个小模块且正在标准化中。后续不会有 CSS4，各个分支独立升级。</p>
<h3 id="CSS-知识点"><a href="#CSS-知识点" class="headerlink" title="CSS 知识点"></a>CSS 知识点</h3><ul>
<li>引用 CSS 的 4 种方式<ul>
<li>内联样式。</li>
<li>style 标签。</li>
<li>外联样式<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; &gt;</code>。</li>
<li>在 css 中引用样式（不推荐）<code>@import&quot;mystyle.css&quot;。 </code></li>
</ul>
</li>
<li>调试时给调试标签加一像素的 border。</li>
<li>使元素排列在一行：给子元素添加浮动，父元素添加 clearfix,不建议使用 overflow:hidden。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br></pre></td></tr></table></figure></li>
<li><code>&lt;a&gt;</code>有默认样式，在全局改变字体颜色，其字体颜色不会改变，添加样式<code>color: inhert</code>使 a 可以继承全局设置的颜色。</li>
<li>标签的高度由其内部文档流元素的高度总和决定.<blockquote>
<p>文档流：内联元素按基线从左往右，块级元素从上往下流动。</p>
</blockquote>
</li>
<li><code>position:relative</code>不会使元素脱离文档流</li>
<li>内联元素的 margin 和 padding 会影响宽，不会影响高，高度取决于 line-height</li>
<li>少用<code>display：inline</code>，有 bug，使用<code>float</code>。</li>
<li>行高建议比字体大，不同字体的建议行高不一样。</li>
<li>字和字通过基线对齐，不是通过中线对齐。</li>
<li><code>position:fix</code>会使宽度缩进去，使用<code>width:100%</code>，但有 padding 时会出 bug，其宽度超过浏览器宽度，可通过在下一级添加一个 div，把左右 padding 加在这个 div 上解决。</li>
<li><code>background-size：cover</code>，<code>background-position：center center</code>:解决背景图片居中、改变背景大小的问题。</li>
<li>用 padding 撑起宽高，尽量少设置宽高，可用 max-width。</li>
<li>span 里不要有 div。</li>
<li><code>boxsizing:content-box</code>:标准盒模型，实际宽高为设置的宽高+内外边距+border。</li>
<li><code>boxsizing:border-box</code>:怪异盒模型，实际宽高就是设置的宽高。</li>
<li>伪元素不能选中。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations">设置动画旋转</a><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">animation</span>： rotate(<span class="number">0deg</span>);&#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;<span class="attribute">animation</span>： rotate(<span class="number">360deg</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"># demo&#123;</span><br><span class="line">    <span class="attribute">animation</span>: rotate <span class="number">2s</span> infinite;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>:linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>下载按钮要用<code>&lt;a&gt;</code>标签做，因为有下载请求。</li>
<li><code>:nth-child(an+b)</code>这个 CSS 伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从 1 开始排序，选择的结果为第（an+b）个元素的集合（n=0，1，2，3…）。</li>
<li>使用<code>display:inline-block</code>会有空隙，要同时使用<code>vertical-align:top</code>。</li>
<li>横线做结构，不做类名。</li>
<li>nbsp 是 no break space 的缩写</li>
<li>在伪类上加<code>padding-top:100%</code>，可以生成个正方形</li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookies</title>
    <url>/2019/01/03/Cookies/</url>
    <content><![CDATA[<h1 id="Cookie-是什么？"><a href="#Cookie-是什么？" class="headerlink" title="Cookie 是什么？"></a>Cookie 是什么？</h1><p>以下是 Web 开发里 Cookie 的含义。</p>
<ol>
<li>Cookie 是浏览器访问服务器后，服务器传给浏览器的<strong>一段数据</strong>。</li>
<li>浏览器需要保存这段数据，不得轻易删除。</li>
<li>此后每次浏览器访问该服务器，都必须带上这段数据。</li>
</ol>
<span id="more"></span>

<h1 id="Cookie-的特点"><a href="#Cookie-的特点" class="headerlink" title="Cookie 的特点"></a>Cookie 的特点</h1><ol>
<li>服务器通过 Set-Cookie 响应头设置 Cookie</li>
<li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie</li>
<li>客户端在一段时间内保存这个 Cookie，时长可通过代码修改</li>
<li>最大一般 4kb</li>
</ol>
<h1 id="Cookie-的用途"><a href="#Cookie-的用途" class="headerlink" title="Cookie 的用途"></a>Cookie 的用途</h1><ol>
<li><p>第一个作用是识别用户身份。</p>
<p>比如用户 A 用浏览器访问了 <a href="http://a.com,那么/">http://a.com，那么</a> <a href="http://a.com/">http://a.com</a> 的服务器就会立刻给 A 返回一段数据「uid=1」（这就是 Cookie）。当 A 再次访问 <a href="http://a.com/">http://a.com</a> 的其他页面时，就会附带上「uid=1」这段数据。</p>
<p>同理，用户 B 用浏览器访问 <a href="http://a.com/">http://a.com</a> 时，<a href="http://a.com/">http://a.com</a> 发现 B 没有附带 uid 数据，就给 B 分配了一个新的 uid，为 2，然后返回给 B 一段数据「uid=2」。B 之后访问 <a href="http://a.com/">http://a.com</a> 的时候，就会一直带上「uid=2」这段数据。</p>
<p>借此，<a href="http://a.com/">http://a.com</a> 的服务器就能区分 A 和 B 两个用户了。</p>
</li>
<li><p>第二个作用是记录历史。</p>
<p>假设 <a href="http://a.com/">http://a.com</a> 是一个购物网站，当 A 在上面将商品 A1 、A2 加入购物车时，JS 可以改写 Cookie，改为「uid=1; cart=A1,A2」，表示购物车里有 A1 和 A2 两样商品了。</p>
<p>这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 A1、A2 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。</p>
<p>借此，就达到里记录用户操作历史的目的了。</p>
</li>
</ol>
<p>（上面的例子只是为了让大家了解 Cookie 的作用而构想出来的，实际的网站使用 Cookie 时会更谨慎一些。）</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/22396872?refer=study-fe">https://zhuanlan.zhihu.com/p/22396872?refer=study-fe</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Cookie">https://zh.wikipedia.org/wiki/Cookie</a></li>
</ul>
]]></content>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入门学习</title>
    <url>/2021/09/22/Docker%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>什么是 Docker ？更小更快速的虚拟机？</p>
<span id="more"></span>

<p>维基百科上这么解释：</p>
<blockquote>
<p>Docker 容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。</p>
</blockquote>
<h1 id="Docker-三个基本概念"><a href="#Docker-三个基本概念" class="headerlink" title="Docker 三个基本概念"></a>Docker 三个基本概念</h1><ol>
<li>镜像（Images）是一个只读模板，用于指示创建容器。 镜像分层(layers)构建的，而定义这些层次的文件叫 Dockerfile，可以本地创建或者拉取别人创建好的镜像。</li>
<li>容器（Containers）是镜像的可运行的实例。容器可通过 API 或 CLI（命令行）进行操控，容器 = 镜像 + 读写层。</li>
<li>仓库（Repository）是集中存放镜像文件的场所。</li>
</ol>
<h1 id="运行-Hello-World"><a href="#运行-Hello-World" class="headerlink" title="运行 Hello World"></a>运行 Hello World</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull library/hello-world</span><br></pre></td></tr></table></figure>

<p><code>docker pull images</code> 是抓取 image 文件，library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。</p>
<p>抓取成功后通过 <code>docker images</code> 就可以查看本机的拉取的 image 文件了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>运行后 hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如 MySQL 镜像等。</p>
<h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker pull image_name  <span class="comment"># 拉取Docker镜像</span></span><br><span class="line">docker images <span class="comment"># 查看主机下存在多少镜像</span></span><br><span class="line">docker ps <span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker start container_id <span class="comment">#启动</span></span><br><span class="line">docker restart container_id <span class="comment">#重启</span></span><br><span class="line">docker stop container_id <span class="comment">#停止</span></span><br><span class="line">docker exec -it container_id bash <span class="comment">#进入容器中</span></span><br><span class="line">docker rm container_name/container_id <span class="comment">#删除容器</span></span><br><span class="line">docker rmi image_name <span class="comment">#删除镜像</span></span><br></pre></td></tr></table></figure>

<h1 id="使用-Dockerfile-创建镜像命令"><a href="#使用-Dockerfile-创建镜像命令" class="headerlink" title="使用 Dockerfile 创建镜像命令"></a>使用 Dockerfile 创建镜像命令</h1><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="comment"># 用于指定基础的 images ，一般格式为 FROM &lt;image&gt; or FORM &lt;image&gt;:&lt;tag&gt;</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> <span class="comment">#用于指定镜像创建者和联系方式，一般格式为 MAINTAINER &lt;name&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="comment">#用于复制本地主机的 &lt;src&gt; (为 Dockerfile 所在目录的相对路径)到容器中的 &lt;dest&gt; ,当使用本地目录为源目录时，推荐使用 COPY</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="comment">#用于配合 RUN，CMD，ENTRYPOINT 命令设置当前工作路径</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="comment">#用于容器内部执行命令。每个 RUN 命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="comment">#用来指定对外开放的端口</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="comment">#指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行，可被替代。</span></span></span><br></pre></td></tr></table></figure>

<p>例如在当前目录新建 Dockerfile 并写入</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;hello.xxx&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>

<p>然后在当前目录运行 <code>docker build -t image_name .</code></p>
<ul>
<li>-t 是为新镜像设置仓库和名称</li>
<li>image_name 为镜像名称</li>
<li>. 为 Dockerfile 的相对路径</li>
</ul>
<p>运行成功 运行 <code>docker images</code> 就可以看见新建的镜像了</p>
<p>然后运行:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name [container_name] -d -d -p 7301:80 [image_name] <span class="comment">#这条命令会用 Nginx 镜像启动一个容器，命名为 container_name ，并且映射了 7301 端口。</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Docker">Docker</a></li>
<li><a href="https://juejin.cn/post/6844903713115488269#heading-0">这可能是最为详细的 Docker 入门总结</a></li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用操作</title>
    <url>/2018/10/11/Git%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>使用 Git 前，需要先建立一个仓库(repository)。我们可以使用一个已经存在的目录作为 Git 仓库或创建一个空目录。<br>使用当前目录作为 Git 仓库，我们只需使它初始化。</p>
<span id="more"></span>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><code>git init</code></p>
<p>运行后会在当前文件夹建立一个<code>.git</code>的文件夹，此时仓库是没有其他文件的，我们可以通过<code>add</code>命令增加文件。</p>
<p><code>git add filename</code></p>
<p>现在我们已经添加了这些文件，我们希望它们能够真正被保存在 Git 仓库。为此，我们将它们提交到仓库。</p>
<p><code>git commit -m &quot;Adding files&quot;</code></p>
<p>可以通过</p>
<p><code>git commit -v</code></p>
<p>查看所有 diff 信息</p>
<p>当我们修改了很多文件，而不想每一个都 add，想 commit 自动来提交本地修改，我们可以使用-a 标识。</p>
<p><code>git commit -a -m &quot;Changed some files&quot;</code></p>
<p><code>git commit</code>命令的<code>-a</code>选项可将所有被修改或者已删除的且已经被 git 管理的文档提交到仓库中。<br>千万注意，<code>-a</code>不会造成新文件被提交，只能修改。</p>
<p><code>git pull</code></p>
<p>拉取线上代码，有可能会有冲突，这时需要手动合并冲突，并提交，vscode 有代码合并工具，方便合并代码。</p>
<p><code>git push</code></p>
<p>提交本地代码到线上</p>
<h1 id="处理-bug"><a href="#处理-bug" class="headerlink" title="处理 bug"></a>处理 bug</h1><p>当代码出现 bug 时，可以将当前代码先提交，注意一定要先提交成功，然后执行 <code>git reset --hard commitID</code>，重置到指定 commit 时的版本。可以通过<code>git show commitID</code> 查看提交时的代码。</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p><code>git branch 分支名</code> 创建一个分支<br><code>git push origin 本地分支名:远程</code> 提交本地分支到远程<br><code>git checkout 分支名</code> 切换到另一个分支</p>
<h1 id="通常提交代码流程"><a href="#通常提交代码流程" class="headerlink" title="通常提交代码流程"></a>通常提交代码流程</h1><ol>
<li><code>git add .</code> 通常来讲每次的 add 都是一种类型修改提交，不建议一次提交所有</li>
<li><code>git commit</code></li>
<li><code>git pull</code> 注意 push 前一定要 pull 代码</li>
<li><code>git push</code></li>
</ol>
<h1 id="更多技巧"><a href="#更多技巧" class="headerlink" title="更多技巧"></a>更多技巧</h1><ol>
<li><code>git reflog</code> 查看 reset 之前的时间点，使用 <code>git reset --hard</code> 返回之前时间点;</li>
<li><code>git commit . --amend</code> 当前代码提交到上一次提交里;</li>
<li><code>git rebase -i HEAD~3</code> 对最近的三次 commit 进行合并、修改;</li>
<li><code>git rm --cached xxx</code> 用于 xxx 虽然被写入 .gitignore 但依然被提交了的情况;</li>
<li><code>git add . ; git stash</code> 有时代码还没提交，但需要 <code>git pull</code>; pull 结束后再用 <code>git stash pop</code> 将其召唤回来</li>
</ol>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">git 详解</a></p>
</li>
<li><p><a href="https://xiedaimala.com/tasks/24e32d28-9aeb-4010-a643-d97904e8101d/text_tutorials/317c56bc-d774-415c-9594-4b11e67a3f5d">Git 操作手册</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求与响应</title>
    <url>/2018/10/13/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h3 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h3><p>HTTP（HyperText Transfer Protocol）请求信息至少由 3 部分组成</p>
<ul>
<li>请求方法（GET/POST）、URI、协议版本</li>
<li>请求头（Request Header）</li>
<li>空行（\n）</li>
<li>请求正文</li>
</ul>
<span id="more"></span>

<p>或</p>
<p>＜ request-line ＞</p>
<p>＜ headers ＞</p>
<p>＜ blank line ＞</p>
<p>＜ request-body ＞</p>
<ol>
<li><p>请求方法（GET/POST）、URI、协议版本</p>
<ul>
<li>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。例如：HTTP1.1 目前支持 7 种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE 和 TARCE。</li>
<li>在 Internet 应用中，最常用的方法是 GET 和 POST。</li>
</ul>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>请求获取由 Request-URI 所标识的资源</td>
</tr>
<tr>
<td>POST</td>
<td>在 Request-URI 所标识的资源后附加新的数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取由 Request-URI 所标识的资源的响应消息报头</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>请求查询服务器的性能，或查询与资源相关的选项和需求</td>
</tr>
<tr>
<td>PUT</td>
<td>请求服务器存储一个资源，并用 Request-URI 作为其标识</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除由 Request-URI 所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>请求服务器回送收到的请求信息，主要用语测试或诊断</td>
</tr>
</tbody></table>
</li>
<li><p>请求头(Request Header)</p>
<ul>
<li>请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。</li>
</ul>
<table>
<thead>
<tr>
<th>请求头</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td>是返回消息中非常重要的内容，表示后面的文档属于什么 MIME 类型。Content-Type: [type]/[subtype]; parameter。例如最常见的就是 text/html，它的意思是说返回的内容是文本类型，这个文本又是 HTML 格式的。原则上浏览器会根据 Content-Type 来决定如何显示返回的消息体内容</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求资源的 Intenet 主机和端口号，必须表示请求 url 的原始服务器或网关的位置。HTTP/1.1 请求必须包含主机头域，否则系统会以 400 状态码返回</td>
</tr>
<tr>
<td>Accept</td>
<td>浏览器可接受的 MIME 类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>浏览器能够进行解码的数据编码方式，比如 gzip。Servlet 能够向支持 gzip 的浏览器返回经 gzip 编码的 HTML 页面。许多情形下这可以减少 5 到 10 倍的下载时间</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到</td>
</tr>
<tr>
<td>Authorization</td>
<td>授权信息，通常出现在对服务器发送的 WWW-Authenticate 头的应答中</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。如果 Servlet 看到这里的值为“Keep- Alive”，或者看到请求使用的是 HTTP1.1（HTTP 1.1 默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如 Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet 需要在应答中发送一个 Content-Length 头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小</td>
</tr>
<tr>
<td>Content-Length</td>
<td>表示请求消息正文的长度</td>
</tr>
<tr>
<td>Cookie</td>
<td>这是最重要的请求头信息之一</td>
</tr>
<tr>
<td>From</td>
<td>请求发送者的 email 地址，由一些特殊的 Web 客户程序使用，浏览器不会用到它</td>
</tr>
<tr>
<td>Host</td>
<td>初始 URL 中的主机和端口</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回 304“Not Modified”应答</td>
</tr>
<tr>
<td>Pragma</td>
<td>指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝</td>
</tr>
<tr>
<td>Referer</td>
<td>包含一个 URL，用户从该 URL 代表的页面出发访问当前请求的页面</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器类型，如果 Servlet 返回的内容与浏览器类型有关则该值非常有用</td>
</tr>
<tr>
<td>UA-Pixels，UA-Color，UA-OS，UA-CPU</td>
<td>由某些版本的 IE 浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和 CPU 类型</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li><p>常见的 MIME 类型如下：</p>
<ol>
<li>text/html ： HTML 格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ： XML 格式</li>
<li>image/gif ：gif 图片格式</li>
<li>image/jpeg ：jpg 图片格式</li>
<li>image/png：png 图片格式</li>
<li>application/xhtml+xml ：XHTML 格式</li>
<li>application/xml ： XML 数据格式</li>
<li>application/atom+xml ：Atom XML 聚合格式</li>
<li>application/json ： JSON 数据格式</li>
<li>application/pdf ：pdf 格式</li>
<li>application/msword ： Word 文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ： <code>&lt;form encType=””&gt;</code>中默认的 encType，form 表单数据被编码为 key/value 格式发送到服务器（表单默认的提交数据的格式）</li>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>空行</p>
<ul>
<li>表示请求头已经结束，接下来的是请求正文</li>
</ul>
</li>
<li><p>请求正文</p>
<ul>
<li>请求正文中可以包含客户提交的查询字符串信息，也可以为空</li>
</ul>
</li>
</ol>
<h3 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h3><p>HTTP 应答与 HTTP 请求相似，HTTP 响应也由 3 个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>空行（\n）</li>
<li>响应正文</li>
</ul>
<ol>
<li><p>状态行</p>
<ul>
<li>由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔，例如<code>HTTP/1.1 200 OK</code></li>
<li>状态码有如下几种：<ul>
<li>1xx:指示信息—表示请求已接收，继续处理。</li>
<li>2xx:成功—表示请求已经被成功接收、理解、接受。</li>
<li>3xx:重定向—要完成请求必须进行更进一步的操作。</li>
<li>4xx:客户端错误—请求有语法错误或请求无法实现。</li>
<li>5xx:服务器端错误—服务器未能实现合法的请求。<blockquote>
<p>wiki 百科 HTTP 状态码(需翻墙)：<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>响应头</p>
<ul>
<li>响应头可能包括：</li>
</ul>
<p>Location：</p>
<p>Location 响应报头域用于重定向接受者到一个新的位置。例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务 器端可以发回 Location 响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源。当我们在 JSP 中使用重定向语句的时候，服务器 端向客户端发回的响应报头中，就会有 Location 响应报头域。</p>
<p>Server：</p>
<p>Server 响应报头域包含了服务器用来处理请求的软件信息。它和 User-Agent 请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户 端软件(浏览器)和操作系统的信息。下面是 Server 响应报头域的一个例子：Server: Apache-Coyote/1.1</p>
<p>WWW-Authenticate：</p>
<p>WWW-Authenticate 响应报头域必须被包含在 401(未授权的)响应消息中，这个报头域和前面讲到的 Authorization 请求报头域是 相关的，当客户端收到 401 响应消息，就要决定是否请求服务器对其进行验证。如果要求服务器对其进行验证，就可以发送一个包含了 Authorization 报头域的请求，下面是 WWW-Authenticate 响应报头域的一个例子：WWW-Authenticate: Basic realm=”Basic Auth Test!”</p>
<p>从这个响应报头域，可以知道服务器端对我们所请求的资源采用的是基本验证机制。</p>
<p>Content-Encoding：</p>
<p>Content-Encoding 实体报头域被使用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容编码，因而要获得 Content- Type 报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding 主要用语记录文档的压缩方法，下面是它的一个例子： Content-Encoding: gzip。如果一个实体正文采用了编码方式存储，在使用之前就必须进行解码。</p>
<p>Content-Language：</p>
<p>Content-Language 实体报头域描述了资源所用的自然语言。Content-Language 允许用户遵照自身的首选语言来识别和区分实体。 如果这个实体内容仅仅打算提供给丹麦的阅读者，那么可以按照如下的方式设置这个实体报头域：Content-Language: da。</p>
<p>Content-Length：</p>
<p>Content-Length 实体报头域用于指明正文的长度，以字节方式存储的十进制数字来表示，也就是一个数字字符占一个字节，用其对应的 ASCII 码存储传输。<br>注意的是：这个长度仅仅是表示实体正文的长度，没有包括实体报头的长度。</p>
<p>Content-Type</p>
<p>Content-Type 实体报头域用语指明发送给接收者的实体正文的媒体类型。</p>
<p>Last-Modified</p>
<p>Last-Modified 实体报头域用于指示资源最后的修改日期及时间。</p>
<p>Expires</p>
<p>Expires 实体报头域给出响应过期的日期和时间。通常，代理服务器或浏览器会缓存一些页面。当用户再次访问这些页面时，直接从缓存中加载并显示给用 户，这样缩短了响应的时间，减少服务器的负载。为了让代理服务器或浏览器在一段时间后更新页面，我们可以使用 Expires 实体报头域指定页面过期的时 间。当用户又一次访问页面时，如果 Expires 报头域给出的日期和时间比 Date 普通报头域给出的日期和时间要早(或相同)，那么代理服务器或浏览器就 不会再使用缓存的页面而是从服务器上请求更新的页面。不过要注意，即使页面过期了，也并不意味着服务器上的原始资源在此时间之前或之后发生了改变。</p>
</li>
<li><p>表示分隔</p>
</li>
<li><p>要下载的内容</p>
</li>
</ol>
<h3 id="关于-HTTP-请求-GET-和-POST-的区别"><a href="#关于-HTTP-请求-GET-和-POST-的区别" class="headerlink" title="关于 HTTP 请求 GET 和 POST 的区别"></a>关于 HTTP 请求 GET 和 POST 的区别</h3><ul>
<li><p>提交</p>
<ul>
<li><p>GET 提交，请求的数据会附在 URL 之后（就是把数据放置在 HTTP 协议头＜ request-line ＞中）， 以?分割 URL 和传输数据，多个参数用&amp;连接;例如：<code>login.action?name=hyddd&amp; password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD</code>。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX 中的 XX 为该符号以 16 进制表示的 ASCII。</p>
</li>
<li><p>POST 提交：把提交的数据放置在是 HTTP 包的包体＜ request-body ＞中。</p>
</li>
</ul>
<p>因此，GET 提交的数据会在地址栏中显示出来，而 POST 提交，地址栏不会改变。</p>
</li>
<li><p>传输数据的大小：</p>
<p>首先声明,HTTP 协议没有对传输的数据大小进行限制，HTTP 协议规范也没有对 URL 长度进行限制。 而在实际开发中存在的限制主要有：</p>
<ul>
<li>GET:特定浏览器和服务器对 URL 长度有限制，例如 IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。</li>
</ul>
<p>因此对于 GET 提交时，传输数据就会受到 URL 长度的限制。</p>
<ul>
<li>POST:由于不是通过 URL 传值，理论上数据不受限。但实际各个 WEB 服务器会规定对 post 提交数据大小进行限制，Apache、IIS6 都有各自的配置。</li>
</ul>
</li>
<li><p>安全性：</p>
<ul>
<li>POST 的安全性要比 GET 的安全性高。比如：通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</li>
</ul>
</li>
</ul>
<h3 id="使用开发者工具查看-HTTP-请求内容和响应内容"><a href="#使用开发者工具查看-HTTP-请求内容和响应内容" class="headerlink" title="使用开发者工具查看 HTTP 请求内容和响应内容"></a>使用开发者工具查看 HTTP 请求内容和响应内容</h3><ol>
<li>请求</li>
</ol>
<ul>
<li>打开 Network</li>
<li>地址栏输入网址</li>
<li>在 Network 点击，查看 request Headers，点击「view source」,可以看见第一部分和第二部分，第三部分空行看不见</li>
<li>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</li>
</ul>
<ol start="2">
<li>响应</li>
</ol>
<ul>
<li>打开 Network</li>
<li>地址栏输入网址</li>
<li>选中第一个响应查看 Response Headers，点击「view source」，你会看到响应的前两部分</li>
<li>查看 Response 或者 Preview，你会看到响应的第 4 部分</li>
</ul>
<h3 id="curl-命令的使用"><a href="#curl-命令的使用" class="headerlink" title="curl 命令的使用"></a>curl 命令的使用</h3><ul>
<li>curl 是一个利用 URL 规则在命令行下工作的文件传输工具，可以说是一款很强大的 http 命令行工具。它支持文件的上传和下载，是综合传输工具</li>
<li>语法：<code>curl [option] [url]</code></li>
<li>常见参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A/--user-agent &lt;string&gt;              设置用户代理发送给服务器</span><br><span class="line">-b/--cookie &lt;name=string/file&gt;    cookie字符串或文件读取位置</span><br><span class="line">-c/--cookie-jar &lt;file&gt;                    操作结束后把cookie写入到这个文件中</span><br><span class="line">-C/--continue-at &lt;offset&gt;            断点续转</span><br><span class="line">-D/--dump-header &lt;file&gt;              把header信息写入到该文件中</span><br><span class="line">-e/--referer                                  来源网址</span><br><span class="line">-f/--fail                                          连接失败时不显示http错误</span><br><span class="line">-o/--output                                  把输出写到该文件中</span><br><span class="line">-O/--remote-name                      把输出写到该文件中，保留远程文件的文件名</span><br><span class="line">-r/--range &lt;range&gt;                      检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line">-s/--silent                                    静音模式。不输出任何东西</span><br><span class="line">-T/--upload-file &lt;file&gt;                  上传文件</span><br><span class="line">-u/--user &lt;user[:password]&gt;      设置服务器的用户和密码</span><br><span class="line">-w/--write-out [format]                什么输出完成后</span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              在给定的端口上使用HTTP代理</span><br><span class="line">-#/--progress-bar                        进度条显示当前的传送状态</span><br></pre></td></tr></table></figure>

<ul>
<li>Linux curl 命令详解:<a href="https://www.cnblogs.com/duhuo/p/5695256.html"><code>click here</code></a></li>
</ul>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客搭建</title>
    <url>/2022/01/24/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>使用 GitHub Pages + Hexo 实现自动部署的个人技术博客搭建。</p>
<span id="more"></span>

<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><pre><code>npm install -g hexo-cli
</code></pre>
<p>Hexo 安装好了后，执行以下命令初始项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init 文件夹</span><br><span class="line">$ cd 文件夹</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>运行 <code>hexo server</code> 启动服务，默认运行在 <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
<p>博客 <code>.md</code> 文件在项目的 <code>source/_posts</code> 文件夹中，现在就可以在该文件夹中增加。</p>
<h3 id="配置浏览器热更新"><a href="#配置浏览器热更新" class="headerlink" title="配置浏览器热更新"></a>配置浏览器热更新</h3><p>有个问题，我们编辑在博客的时候，本地的浏览器不能动态更新，需要手动刷新浏览器，这很麻烦。</p>
<p>安装 browsersync 浏览器热更新</p>
<pre><code>npm i hexo-browsersync -D
</code></pre>
<p>然后重启服务</p>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>我使用的是 <code>Next</code> 主题，主题风格简约，适合我的口味。有多种下载方式，按需选择</p>
<p>下载好之后，解压到 <code>/theme/next</code> 文件夹中，然后在项目的 <code>/_config.yml</code> 配置文件中设置 <code>theme: next</code> 即可，主注意空格和缩进。</p>
<h3 id="部署到-GitHub-Pages"><a href="#部署到-GitHub-Pages" class="headerlink" title="部署到 GitHub Pages"></a>部署到 GitHub Pages</h3><ol>
<li>新建名称为 <code>GitHub名称.github.io</code> 的仓库，然后将本地未编译文件上传到仓库；</li>
<li>新建<code>gh-pages</code> 分支，Hexo 有 <code>hexo generate</code> 命令将我们的文件打包成 html 等静态文件，文件放在 <code>/public</code> 目录切换分支，编译好后上传；</li>
<li>在仓库 <code>Setting/GitHub Pages/Source</code> 将分支改成 <code>gh-pages</code> 就可以了，然后在 <code>GitHub名称.github.io</code> 访问自己的博客了。</li>
</ol>
<h3 id="配置-Action-自动部署"><a href="#配置-Action-自动部署" class="headerlink" title="配置 Action 自动部署"></a>配置 Action 自动部署</h3><p>每次都要上传太麻烦了，能不能每次 push 后自动部署呢？答案是肯定的。</p>
<ol>
<li>新建 <code>.github/workflows/pages.yml</code> 配置文件，并增加以下配置;</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># default branch master | main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">16.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;16&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一旦部署完毕，就能在 <code>gh-pages</code> 分支看到编译好的文件，由于之前我们文件分支也在 <code>gh-pages</code>，并且配置好了 <code>GitHub Pages</code>，因此提交好后就能自动部署了；</li>
</ol>
<h3 id="碰到的一些问题"><a href="#碰到的一些问题" class="headerlink" title="碰到的一些问题"></a>碰到的一些问题</h3><ol>
<li>在 next 主题配置中，增加 tags 目录，访问会报 404</li>
</ol>
<p>解决方法 ：在 <code>/source</code> 文件夹中新建 <code>tags/index.md</code>文件，文件内容</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: tags</span><br><span class="line"><span class="section">layout: &#x27;tags&#x27;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新后 CNAME 丢失</li>
</ol>
<p>解决方法：CNAME 放到 <code>/source</code> 文件夹</p>
<ol start="3">
<li>自动部署后时间变为部署时间</li>
</ol>
<p>解决方法：增加 <code>date</code>、<code>updated</code> 手动维护时间</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://hexo.io/docs/#Install-Hexo">Hexo Documentation</a></li>
<li><a href="http://www.leojuly.top/2018/11/26/Hexo-browsersync/">Hexo 使用 browsersync 浏览器热更新</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next</a></li>
<li><a href="https://hexo.io/docs/github-pages">GitHub Actions </a></li>
<li><a href="https://github.com/theme-next/hexo-theme-next/issues/893">The update time of the article is incorrect </a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的数据类型</title>
    <url>/2018/11/25/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值)，所以现在有七种，分别为：</p>
<span id="more"></span>

<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>symbol</li>
<li>undefined</li>
<li>null</li>
<li>object 复杂类型，由以上 6 种简单类型数据组成</li>
</ul>
<h1 id="number"><a href="#number" class="headerlink" title="number"></a>number</h1><p>JavaScript 内部，所有数字都是以 64 位浮点数形式存储的，即是整数也是。所以 1 与 1.0 是相同的（1===1.0 返回<code>true</code>），是同一个数。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要小心</p>
<h2 id="范围及精度"><a href="#范围及精度" class="headerlink" title="范围及精度"></a>范围及精度</h2><p>JavaScript 能够表示的数值范围为 2<sup>1024</sup>到 2<sup>-1023</sup>（开区间），超出这个范围的数无法表示，返回 Infinity 或者 0;</p>
<p>Javascript 提供 Number 对象 MAX_VALUE 和 MIN_VALUE 属性，返回表示的最大值和最小值</p>
<p>JavaScript 对-2<sup>53</sup>到 2<sup>53</sup>的数值，都可以精确表示，简单表示的话对 15 位的十进制数都可以精确处理</p>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制</p>
<ul>
<li>十进制：没有前导 0 的数值。</li>
<li>八进制：有前缀 0o 或 0O 的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。</li>
<li>十六进制：有前缀 0x 或 0X 的数值。</li>
<li>二进制：有前缀 0b 或 0B 的数值。</li>
</ul>
<p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制</p>
<p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错</p>
<p>通常来说，有前导 0 的数值会被视为八进制，但是如果前导 0 后面有数字 8 和 9，则该数值被视为十进制</p>
<h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><p>NaN 是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。NaN 不等于任何值，包括它本身。</p>
<p>NaN 与任何数（包括它自己）的运算，得到的都是 NaN。</p>
<h2 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h2><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p>parseInt 方法用于将字符串转为整数（返回值十进制，或者 NaN）。</p>
<p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p>
<p>如果 parseInt 的第一个参数<strong>不是字符串</strong>，会被先转为字符串<strong>String(010)的结果是 9</strong>，对于八进制的前缀 0，尤其需要注意。</p>
<p>如果<strong>字符串</strong>以 0x 或 0X 开头，parseInt 会将其按照十六进制数解析。如果字符串以 0 开头，将其按照 10 进制解析。</p>
<p>parseInt 方法还可以接受第二个参数（2 到 36 之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt 的第二个参数为 10，即默认是十进制转十进制。超出这个范围，则返回 NaN。</p>
<p>如果第二个参数是 0、undefined 和 null，则直接忽略。</p>
<p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。</p>
<p>如果最高位无法转换，则直接返回 NaN。</p>
<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p>parseFloat 方法用于将一个字符串转为浮点数。</p>
<p>如果字符串符合科学计数法，则会进行相应的转换。</p>
<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回 NaN。</p>
<h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p>isNaN 方法可以用来判断一个值是否为 NaN。</p>
<p>判断 NaN 更可靠的方法是，利用 NaN 为唯一不等于自身的值的这个特点，进行判断。</p>
<h3 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h3><p>isFinite 方法返回一个布尔值，表示某个值是否为正常的数值。</p>
<p>除了 Infinity、-Infinity、NaN 和 undefined 这几个值会返回 false，isFinite 对于其他的数值都会返回 true。</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。此外，因为字符串是不允许多行的，如果想多行显示，建议使用<code>+</code>连接。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>
<p>反斜杠还有三种特殊用法。</p>
<ul>
<li>反斜杠后面紧跟三个八进制数（000 到 377），代表一个字符。HHH 对应该字符的 Unicode 码点，比如\251 表示版权符号。显然，这种方法只能输出 256 种字符。</li>
<li>\x 后面紧跟两个十六进制数（00 到 FF），代表一个字符。HH 对应该字符的 Unicode 码点，比如\xA9 表示版权符号。这种方法也只能输出 256 种字符。</li>
<li>\u 后面紧跟四个十六进制数（0000 到 FFFF），代表一个字符。XXXX 对应该字符的 Unicode 码点，比如\u00A9 表示版权符号。</li>
</ul>
<h2 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h2><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从 0 开始）。</p>
<p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回 undefined。</p>
<p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p>
<p>length 属性返回字符串的长度，该属性也是无法改变的</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p>
<p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx 的形式，其中 xxxx 代表该字符的 Unicode 码点。比如，\u00A9 代表版权符号。</p>
<p>我们还需要知道，每个字符在 JavaScript 内部都是以 16 位（即 2 个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为 16 位长度，即 2 个字节。对于码点在 U+10000 到 U+10FFFF 之间的字符，长度为 32 位（即 4 个字节），而且前两个字节在 0xD800 到 0xDBFF 之间，后两个字节在 0xDC00 到 0xDFFF 之间。举例来说，码点 U+1D306 对应的字符为 𝌆，它写成 UTF-16 就是 0xD834 0xDF06。<br>对于码点在 U+10000 到 U+10FFFF 之间的字符，JavaScript 总是认为它们是两个字符（length 属性为 2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p>
<h2 id="Base64-转码"><a href="#Base64-转码" class="headerlink" title="Base64 转码"></a>Base64 转码</h2><p>Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。</p>
<p>全局函数 btoa() 能将字符串转为 Base64 编码。<br>全局函数 atob() 能将 Base64 编码转为原来的编码。</p>
<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line">b64Decode(<span class="string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h1><p>注意，空数组（[]）和空对象（{}）对应的布尔值，都是 true。</p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p>
<p>Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<p>注意，Symbol 函数前不能使用 new 命令，否则会报错。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="undefined-null"><a href="#undefined-null" class="headerlink" title="undefined,null"></a>undefined,null</h1><p>一般两者没区别，只是按照惯例<strong>undefined</strong>表示一个变量未赋值，<strong>null</strong>表示一个 object 未赋值。</p>
<h1 id="object"><a href="#object" class="headerlink" title="object"></a>object</h1><p>简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>

<p>以上三种方法都能建一个对象。</p>
<p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。</p>
<p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>如果属性的值还是一个对象，就形成了链式引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">o1.foo = o2</span><br><span class="line">o1.foo.bar <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = o1</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span></span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.b = <span class="number">2</span></span><br><span class="line">o1.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p>
<h2 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h2><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>
<p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含 foo 属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签 foo，指向表达式 123。</p>
<p>为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="comment">// &#123;foo: 123&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果没有圆括号，eval 将其理解为一个代码块；加上圆括号以后，就理解成一个对象。</p>
<h2 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h2><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;whosyourdaddy&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;p&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj.[foo] <span class="comment">// &quot;whosyourdaddy&quot;</span></span><br></pre></td></tr></table></figure>

<p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p>
<p>查看一个对象本身的所有属性，可以使用 Object.keys 方法。</p>
<p>delete 命令用于删除对象的属性(键名和键值一并删除)，删除成功后返回 true。</p>
<p>注意，删除一个不存在的属性，delete 不报错，而且返回 true。</p>
<p>另外，需要注意的是，delete 命令只能删除对象本身的属性，无法删除继承的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h2><p>in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回 true，否则返回 false。它的左边是一个字符串，表示属性名，右边是一个对象。</p>
<p>in 运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象 obj 本身并没有 toString 属性，但是 in 运算符会返回 true，因为这个属性是继承的。</p>
<p>这时，可以使用对象的 hasOwnProperty 方法判断一下，是否为对象自身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h2><p>for…in 循环用来遍历一个对象的全部属性。</p>
<p>for…in 循环有两个使用注意点。</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p>如果继承的属性是可遍历的，那么就会被 for…in 循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用 for…in 的时候，应该结合使用 hasOwnProperty 方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p>
<h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><p>with 语句的格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (对象) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p>
<p>注意，如果 with 区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<p>单纯从上面的代码块，根本无法判断 x 到底是全局变量，还是对象 obj 的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用 with 语句，可以考虑用一个临时变量代替 with。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (obj1.obj2.obj3) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p1 + p2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://github.com/ruanyf/es6tutorial/blob/3c44084f4b2e318fcbec77b7191b1f2412726c47/docs/symbol.md">https://github.com/ruanyf/es6tutorial/blob/3c44084f4b2e318fcbec77b7191b1f2412726c47/docs/symbol.md</a></li>
<li><a href="https://wangdoc.com/javascript/types/index.html">https://wangdoc.com/javascript/types/index.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JS里的数据类型转换</title>
    <url>/2018/11/27/JS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>JS 里有许多方式可以实现数据类型的转换。以下主要讲的是<code>number</code>、<code>string</code>、<code>boolean</code>这三种类型的转换。</p>
<span id="more"></span>

<p>任意类型 x</p>
<h1 id="x-转换成-number"><a href="#x-转换成-number" class="headerlink" title="x 转换成 number"></a>x 转换成 number</h1><p>主要是 string 转换成 number</p>
<ul>
<li>通过<code>Number(x)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0x11&#x27;</span>) <span class="comment">// 17</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0b11&#x27;</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0o11&#x27;</span>) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;100a&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>parseInt(x,10)</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">MDN</a></li>
<li>通过<code>parseFloat(x)</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat">MDN</a></li>
<li>通过数值运算符<code>+</code>或者<code>x-0</code></li>
</ul>
<h1 id="x-转换成-boolean"><a href="#x-转换成-boolean" class="headerlink" title="x 转换成 boolean"></a>x 转换成 boolean</h1><ul>
<li>通过 Boolean(x)</li>
<li>通过<code>!!x</code></li>
</ul>
<p>5 个 falsy 值：0,NaN,null,’’,undefined，这五个值转换成布尔值都为 false，其余都是 true</p>
<h1 id="x-转换成-string"><a href="#x-转换成-string" class="headerlink" title="x 转换成 string"></a>x 转换成 string</h1><p>主要是 number 转换成 string，object 转换后的值是<code>[object Object]</code></p>
<ul>
<li>x.toString()</li>
<li>String(x)</li>
<li>x + ‘’</li>
</ul>
<h1 id="关于对象和普通类型数据的区别"><a href="#关于对象和普通类型数据的区别" class="headerlink" title="关于对象和普通类型数据的区别"></a>关于对象和普通类型数据的区别</h1><p>object 是复杂数据类型，普通类型的数据是简单数据类型，两者在内存中的存放位置是不一样的。</p>
<p>JS 引擎将内存分为代码区和数据区。数据区可分为堆内存和栈内存。普通类型的数据是存储在 stack（栈内存）中的，而 object 的数据是存储在 heap（堆内存）中，其地址是存在栈内存中。</p>
<p>我们通过以下例子，更深入理解两者区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">//b=1</span></span><br><span class="line">b = <span class="number">2</span> <span class="comment">//不会影响 a</span></span><br><span class="line"><span class="comment">//请问 a 显示是几？  2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span> &#125; <span class="comment">//在栈内存有一个地址，引用堆内存中的数据&#123;name: &#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">// 在栈内存有一个与a一样的地址，引用堆内存中的数据&#123;name: &#x27;a&#x27;&#125;</span></span><br><span class="line">b = &#123; <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span> &#125; <span class="comment">//在栈内存有一个与b一样的地址，引用堆内存中的数据&#123;name: &#x27;b&#x27;&#125;</span></span><br><span class="line"><span class="comment">//请问现在 a.name 是多少？  &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b.name = <span class="string">&#x27;b&#x27;</span> <span class="comment">//修改了其引用地址的数据的name属性</span></span><br><span class="line"><span class="comment">//请问现在 a.name 是多少？ &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="literal">null</span> <span class="comment">//只是在栈内存中，b的地址的值变为null，堆内存中的数据没用改动</span></span><br><span class="line"><span class="comment">//请问现在 a 是什么？ &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面的第一个例子，改变 b 不会影响 a，我们把它称为深拷贝，基本类型的赋值操作都是深拷贝。</p>
<p>上面第二个例子，改变 b 影响 a，我们把它称为浅拷贝。对象操作也有深拷贝,就是对 Heap 内存也进行完全的拷贝。</p>
<p>上面第四个例子，如果加上<code>a=null</code>，则堆内存中的数据没有被引用，其内存空间将会被回收，至于什么时候回收？不知道。在 IE 里有个内存泄漏的 Bug，当绑定事件在结束后没有加<code>xxx=null</code>,在页面关闭时，其所占内存不会被释放，除非关闭整个浏览器。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的生成器</title>
    <url>/2019/06/06/JavaScript%20%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>在看公司之前项目的时候，发现代码中某些函数前有<code>*</code>符号，然后函数内部也有<code>yield</code>，心想这是什么写法，难道 JavaScript 又更新了吗，翻了一下资料，发现这写法早就有了，在 ES6 中叫生成器。</p>
<span id="more"></span>

<p>Generator 函数有多种理解角度。</p>
<p>从语法上，可以理解 Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>从形式上，Generator 函数是一个普通函数，但有个特征，一是 function 关键字与函数名之间有一个星号<code>function* foo(x, y) &#123; ··· &#125;</code>；二是函数内部使用<code>yield</code>表达式，定义不同的内部状态。</p>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该<strong>函数并不执行，返回的也不是函数运行结果</strong>，而<strong>是一个指向内部状态的指针对象</strong>。 下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。</p>
<p>yield 表达式后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p>
<p>yield 表达式与 return 语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到 yield，函数暂停执行，下一次再从该位置继续向后执行，而 return 语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return 语句，但是可以执行多次（或者说多个）yield 表达式。正常函数只能返回一个值，因为只能执行一次 return；Generator 函数可以返回一系列的值，因为可以有任意多个 yield。从另一个角度看，也可以说 Generator 生成了一系列的值。</p>
<p>任意一个对象的 Symbol.iterator 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myIterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...myIterable]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>yield 表达式本身没有返回值，或者说总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> y / <span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>)</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>)</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;  2*12/3</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125; 5 + 24 +13</span></span><br></pre></td></tr></table></figure>

<p>for…of 循环可以自动遍历 Generator 函数运行时生成的 Iterator 对象，且此时不再需要调用 next 方法。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深拷贝</title>
    <url>/2020/07/21/JavaScript%20%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>对象的拷贝不像数值或字符串一样，可以用类似 <code>let newValue = value</code> 来进行拷贝，此时 <code>newValue</code> 的值只是 <code>value</code> 的引用，当我们修改 <code>newValue</code> 的值时，<code>value</code> 的值也会改变，这不是我们所想要的结果。</p>
<span id="more"></span>

<h3 id="使用-JSON-parse"><a href="#使用-JSON-parse" class="headerlink" title="使用 JSON.parse()"></a>使用 JSON.parse()</h3><p>当我们确定所拷贝的对象不是很复杂的时候，可以使用 <code>JSON.parse(JSON.stringify(object))</code> 来拷贝对象，但是：</p>
<ol>
<li><p>当被拷贝的对象中有 undefined，function，symbol 等类型时，由于 JSON 不支持，会导致拷贝的对象不完整，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = &#123;&#125;</span><br><span class="line">a.a = 1</span><br><span class="line">a.b = undefined</span><br><span class="line">a.c = ()=&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line">JSON.parse(JSON.stringify(a)) // 得到的对象&#123;a:1&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="deepCopy-函数"><a href="#deepCopy-函数" class="headerlink" title="deepCopy 函数"></a>deepCopy 函数</h3><p>大体思路是递归调用”浅拷贝”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　function deepCopy(p, c) &#123;</span><br><span class="line"></span><br><span class="line">　　　　var c = c || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　　　for (var i in p) &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　if (typeof p[i] === &#x27;object&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line"></span><br><span class="line">　　　　　　&#125; else &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　　　　c[i] = p[i];</span><br><span class="line"></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　return c;</span><br><span class="line">　&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数一般场景也能用，但是复杂的场景如：<code>File()、Set()、Map()</code> 等可能就有问题了，我们可以使用现成的工具函数，如<a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js">lodash 克隆</a></p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://segmentfault.com/a/1190000013131068">ES6 时代，你真的会克隆对象吗(二)</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html">Javascript 面向对象编程（三）：非构造函数的继承</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/03/14/Promise/</url>
    <content><![CDATA[<p>之前在写 ajax 方面的博客的时候，简单的介绍了一下 Promise 在 ajax 里的应用，这次详细的梳理一下 Promise 功能以及原理。</p>
<span id="more"></span>

<h1 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h1><p>首先，Promise 是一个对象，也是一个构造函数。Promise 的设计思想是所有异步任务都返回一个 Promise 实例。Promise 实例有一个 then 方法，用来指定下一步的回调函数。这样可以让异步操作写起来就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 传统写法</span><br><span class="line">step1(function (value1) &#123;</span><br><span class="line">  step2(value1, function(value2) &#123;</span><br><span class="line">    step3(value2, function(value3) &#123;</span><br><span class="line">      step4(value3, function(value4) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Promise 的写法</span><br><span class="line">var doSomething = new Promise()</span><br><span class="line">doSomething.then(&#x27;第一件事&#x27;).then(&#x27;第二件事&#x27;)</span><br></pre></td></tr></table></figure>

<p>上面的例子如果是用回调函数实现会非常麻烦。</p>
<p>Promise 对象的状态不受外界影响。对象有三个状态，<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。一旦状态发生改变（pending -&gt; fulfilled,fulfilled-&gt; reject），就不会在变。</p>
<p>Promise 也有缺点，首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>下面代码创造了一个 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实例生成后，可以用 then 方法指定 resolve 和 reject 的回调函数，then 的第一个参数是成功的回调函数，第二个是失败的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolved.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure>

<p>下面是异步加载图片的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image()</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    image.src = url</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用 Promise 包装了一个图片加载的异步操作。如果加载成功，就调用 resolve 方法，否则就调用 reject 方法。</p>
<p>上面代码中，Promise 新建后立即执行，所以首先输出的是 Promise。然后，then 方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以 resolved 最后输出。</p>
<p>调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用 resolve(1)以后，后面的 console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务.</p>
<h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>Promise 实例具有 then 方法，也就是说，then 方法是定义在原型对象。then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因而可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p>
<h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>Promise.prototype.catch 方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<p>一般来说，不要在 then 方法里面定义 Reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。</p>
<p>如果 Promise 状态已经变成 resolved，再抛出错误是无效的。因为 Promise 的状态一旦发生改变，就不会再变。</p>
<h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h1><p>finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<p>finally 本质上是 then 方法的特例。</p>
<p>finally 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="built_in">this</span>.constructor</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span></span><br><span class="line">      P.resolve(callback()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。（Promise.all 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p>
<p>（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法。 因为改函数执行完自己的 catch(也会变成 resolve。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。和 all()不同的是，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>
<h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>Promise.resolve 方法可以将现有对象转换成 Promise 对象。</p>
<p>Promise.resolve 方法的参数分成四种情况。</p>
<ol>
<li>参数是一个 Promise 实例：Promise.resolve 将不做任何修改、原封不动地返回这个实例。</li>
<li>参数是一个带 then 方法的对象：Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行该对象的 then 方法。</li>
<li>参数不是具有 then 方法的对象，或根本就不是对象：如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved。</li>
<li>不带有任何参数：Promise.resolve 方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用 Promise.resolve 方法。</li>
</ol>
<h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。</p>
<p>注意，Promise.reject()方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数。这一点与 Promise.resolve 方法不一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://wangdoc.com/javascript/async/promise.html">Promise 对象</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/promise">阮一峰 Promise 对象</a></li>
</ul>
]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks 获取“过去”和“未来”的值</title>
    <url>/2020/07/31/React%20Hooks%20%E8%8E%B7%E5%8F%96%E2%80%9C%E8%BF%87%E5%8E%BB%E2%80%9D%E5%92%8C%E2%80%9C%E6%9C%AA%E6%9D%A5%E2%80%9D%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<p>这个标题看起来有点唬啊，其实主要是讲在使用 <code>useState</code> 时，因为使用异步函数而出现的一些问题。</p>
<span id="more"></span>

<p>先讲一下 <code>useState</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure>

<p>当组件被创建而不是重用时，该状态将被赋予初始值 initialState，而之后的重用过程中，不会被重复赋予初始值。</p>
<p>在实例中，可以通过 useState 等方式拥有局部状态。在重用的过程中，这些状态会得到保留。而如果无法重用，状态会被销毁。</p>
<p>需要明确的是，<code>state</code> 作为函数中的一个常量，就是普通的数据，并不存在诸如数据绑定这样的操作来驱使 DOM 发生更新。在调用 <code>setState</code> 后，React 将重新执行 <code>render</code> 函数。</p>
<p>举两个例子，例子中会使用 <code>useRef</code>，useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p>
<h3 id="使用“未来”的值"><a href="#使用“未来”的值" class="headerlink" title="使用“未来”的值"></a>使用“未来”的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  const currentCount = useRef(count);</span><br><span class="line"></span><br><span class="line">  currentCount.current = count;</span><br><span class="line"></span><br><span class="line">  const handleClick = () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      setCount(currentCount.current + 1);</span><br><span class="line">     // setCount(count + 1);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;setCount&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Delay setCount&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子，如果我们在 <code>handleClick</code> 中使用 <code>count</code>而不是 <code>currentCount.current</code>，当我们点击<br><code>Delay setCount</code> 按钮，然后三秒内点两次 <code>setCount</code> 按钮，页面展示的值，先回变成 1、2，然后又会变成 1。</p>
<p><code>count</code>，<code>handleClick</code> 都是 Example 函数作用域中的常量。定时器设置 3000ms 到期后的执行函数为第一次点击 <code>Delay setCount</code> 按钮时的函数，此时 <code>count</code> 的值是 0，和我们点击 <code>setCount</code> 两次时的 <code>count</code> 的值无关。</p>
<p>我们使用 useRef ，设置它的值不会重新触发 render 函数。此时 <code>currentCount.current</code> 的值是最新的 <code>count</code> 的值，因此页面展示的值分别是 1，2，3。</p>
<h3 id="使用“过去”的值"><a href="#使用“过去”的值" class="headerlink" title="使用“过去”的值"></a>使用“过去”的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">理解上面的例子后，我们再理解下面的例子就方便多了。</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">    const [count, setCount] = useState(1);</span><br><span class="line"></span><br><span class="line">    const prevCountRef = useRef(1);</span><br><span class="line">    const prevCount = prevCountRef.current;</span><br><span class="line">    prevCountRef.current = count;</span><br><span class="line"></span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">        setCount(prevCount + count);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;handleClick&#125;&gt;SetCount&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面首次渲染时，<code>count</code> 的值是初始值 1，<code>prevCountRef.current</code>的值是初始值 1</p>
<p>第一次点击 <code>SetCount</code> 按钮，重新执行函数，此时 <code>count</code> 的值是 2，<code>prevCount</code> 的值是上次存的值 1，然后<code>prevCountRef.current</code>更新成了 2。</p>
<p>页面展示的值 1，2，3，5……</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解上面的例子，主要是理解每次 <code>SetCount</code> 后，页面都会重新渲染，每次渲染后的 count、handleClick 的值都是不相关的。</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://juejin.im/post/5ec7372cf265da76de5cd0c9">React Hooks 最佳实践</a></li>
<li><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useref">useRef</a></li>
</ul>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>Session、LocalStorage、HTTP缓存</title>
    <url>/2019/01/08/Session%E3%80%81LocalStorage%E3%80%81HTTP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><ol>
<li>将 SessionID（随机数）通过 Cookie 发给客户端(Session 可以用 LocalStorage + 查询参数实现)</li>
<li>客户端访问服务器时，服务器读取 SessionID</li>
<li>服务器有一块内存（哈希表）保存了所有 session</li>
<li>通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email</li>
<li>这块内存（哈希表）就是服务器上的所有 session</li>
<li>页面关闭的时候，会清空 SessionStorage</li>
<li>Session 在服务器的默认有效时间是 30 分钟,可以通过代码控制失效时间</li>
</ol>
<span id="more"></span>

<h1 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h1><ol>
<li>LocalStorage 跟 HTTP 无关</li>
<li>HTTP 不会带上 LocalStorage 的值</li>
<li>只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格）</li>
<li>每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）</li>
<li>LocalStorage 永久有效，除非用户清理缓存</li>
<li>常用场景：记录有没有提示过用户（没有用的信息，不能记录密码）</li>
</ol>
<h1 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h1><ol>
<li>同上</li>
<li>同上</li>
<li>同上</li>
<li>同上</li>
<li>SessionStorage 在用户关闭页面（会话结束）后就失效</li>
</ol>
<h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><ol>
<li><code>Cache-Control: max-age=300</code>，当用户 300s 内提交请求时，不会像服务器重新请求</li>
<li>首页不要用缓存</li>
</ol>
<h2 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h2><ol>
<li>和 Cache-Control 类似，优先使用 Cache-Control</li>
<li><code>Expires: Wed, 21 Oct 2015 07:28:00 GMT</code>，在某时刻之前的，都不会像服务器重新请求，但是这个‘时刻’是参照本地时间的，会有风险</li>
</ol>
<h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><ol>
<li>服务器响应头有 Etag，其值为响应内容的 MD5</li>
<li>客户端再次访问给定的 URL，会返回 If-None-Match 请求头，值还是 Etag 的值</li>
<li>如果服务器响应内容没更新， 则 If-None-Match 的值和 Etag 的值一致，服务器返回 304；如果值不一致，则表示服务器内容有更新，需要重新下载。</li>
</ol>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><ol>
<li><p>The Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。</p>
</li>
<li><p>If-Modified-Since 是由客户端往服务器发送的请求头，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，而在 Last-Modified 首部中会带有上次修改时间。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Session</tag>
        <tag>LocalStorage</tag>
        <tag>Cache-Control</tag>
        <tag>HTTP缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 配置跳转定义</title>
    <url>/2021/03/18/VSCode%20%E9%85%8D%E7%BD%AE%E8%B7%B3%E8%BD%AC%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>使用 VSCode 的时候，有时想 F12 查看引用组件的内容，不会自动跳转，很不爽。今天鼓捣了一下，总算是可以跳转引用了。</p>
<span id="more"></span>

<p>在项目根目录增加该文件，并且在使用‘@’别名的路径时，也会自动提示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">      &quot;target&quot;: &quot;ES6&quot;,</span><br><span class="line">      &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">      &quot;allowSyntheticDefaultImports&quot;: true,</span><br><span class="line">      &quot;baseUrl&quot;: &quot;./&quot;,</span><br><span class="line">      &quot;paths&quot;: &#123;</span><br><span class="line">        &quot;@/*&quot;: [&quot;src/*&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">      &quot;node_modules&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.jianshu.com/p/1798d57ecdab">vs code 中路径别名（@）提示和转定义等问题 </a></p>
</blockquote>
]]></content>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Router的基本使用</title>
    <url>/2019/04/17/Vue%20Router%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Vue Router 是 Vue.js 官方的路由管理器。现总结一下之前的使用方式。</p>
<span id="more"></span>

<h1 id="使用-Vue-Router"><a href="#使用-Vue-Router" class="headerlink" title="使用 Vue Router"></a>使用 Vue Router</h1><p>在安装 Vue 的时候，会有选项是否安装 Vue Router ，选择 <code>Y</code> 即可，如果当时选择了否，则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i  vue-router</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>

<h1 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;topic&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/topic/:id&amp;:loginname&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: Article</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>形如上述形式的路径即为动态路由，冒号后是参数，可以跟多段参数，每个参数都被设置到 this.$route.params 中。</p>
<p>在 Vue Router 的官方文档中有说明：当参数变化时，组件会被复用，因此组件生命周期钩子不会被再次调用，即当路由一致，参数不一致时，页面不会跳转。</p>
<p>复用组建时，可以通过 watch 监听$route 对象的变化来监测路由是否变化。路由钩子 beforeRouterUpdate 也可以行。</p>
<h1 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h1><p>有时候想同时（同级）展示多个视图，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;slidebar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;topic&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/topic/:id&amp;:loginname&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">main</span>: Article,</span><br><span class="line">        <span class="attr">slidebar</span>: Slidebar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/Create&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/pages/Create/template.vue&#x27;</span>), <span class="comment">//懒加载</span></span><br><span class="line">      <span class="attr">meta</span>: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;</span><br><span class="line">    <span class="comment">// this route requires auth, check if logged in</span></span><br><span class="line">    <span class="comment">// if not, redirect to login page.</span></span><br><span class="line">    store.dispatch(<span class="string">&#x27;checkLogin&#x27;</span>).then(<span class="function"><span class="params">isLogin</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isLogin) &#123;</span><br><span class="line">        next(&#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">          <span class="attr">query</span>: &#123; <span class="attr">redirect</span>: to.fullPath &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next() <span class="comment">// 确保一定要调用 next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的例子 <code>/Create</code> 路由设置了 <code>meta: &#123;requiresAuth: true&#125;</code>，访问该页面需要认证。如未认证，则会跳转到登录页面。</p>
<h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><p>除了使用 <router-link> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.push(location)</span><br></pre></td></tr></table></figure>

<p>想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>当你点击 <router-link> 时，这个方法会在内部调用，所以说，点击 <router-link :to="..."> 等同于调用 router.push(…)。</p>
<h1 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h1><p>vue-router 默认 hash 模式(url 有个符号#) —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p>
<p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问就会返回 404，这就不好看了。</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://juejin.im/entry/597ab13d5188253e0a62efcb">vue-router 使用总结</a></li>
<li><a href="https://www.jianshu.com/p/ac873b45da36">router 安装及使用</a></li>
<li><a href="https://router.vuejs.org/zh/">Vue Router</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Vue Router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue diff 算法解析</title>
    <url>/2020/08/26/Vue%20diff%20%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>diff 算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。在 Vue 虚拟 DOM 渲染成真实 DOM 的新旧 VNode 节点比较更新时，就用到了该算法。</p>
<span id="more"></span>

<h3 id="当数据发生变化时，Vue-是怎么更新节点的？"><a href="#当数据发生变化时，Vue-是怎么更新节点的？" class="headerlink" title="当数据发生变化时，Vue 是怎么更新节点的？"></a>当数据发生变化时，Vue 是怎么更新节点的？</h3><p>Vue 根据真实 DOM 生成一颗 virtual DOM，当 virtual DOM 某个节点的<code>数据</code>改变后会生成一个新的 Vnode，然后 Vnode 和 oldVnode 作对比，发现有不一样的地方就直接修改在真实的 DOM 上，然后使 oldVnode 的值为 Vnode。</p>
<p>diff 的过程就是调用名为 patch 的函数，比较新旧节点，一边比较一边给真实的 DOM 打补丁。</p>
<p>当数据发生改变时，defineProperty set 方法会让调用 Dep.notify 通知所有订阅者 Watcher，订阅者就会调用 patch 给真实的 DOM 打补丁，更新相应的视图。</p>
<h3 id="diff-算法特点"><a href="#diff-算法特点" class="headerlink" title="diff 算法特点"></a>diff 算法特点</h3><ol>
<li>比较只会在同层级进行, 不会跨层级比较。</li>
<li>在 diff 比较的过程中，循环从两边向中间收拢。</li>
</ol>
<h3 id="diff-流程"><a href="#diff-流程" class="headerlink" title="diff 流程"></a>diff 流程</h3><ol>
<li><p>对新老 VNode 的开始和结束位置进行标记：oldStartIdx、oldEndIdx、newStartIdx、newEndIdx。</p>
</li>
<li><p>标记好节点位置之后，就开始进入到的 while 循环处理中，这里是 diff 算法的核心流程，分情况进行了新老节点的比较并移动对应的 VNode 节点。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。循环过程中首先对新老 VNode 节点的头尾进行比较，寻找相同节点，当其中两个能匹配上那么真实 DOM 中的相应节点会移到 Vnode 相应的位置。</p>
<ol>
<li>如果是 oldStartIdx 和 newEndIdx 匹配上了，那么将当前真实 DOM 移到 oldEndIdx 后面，匹配上的两个指针向中间移动；</li>
<li>如果是 oldEndIdx 和 newStartIdx 匹配上了，那么将当前真实 DOM 移到 oldStartIdx 前面，匹配上的两个指针向中间移动；</li>
<li>如果 oldStartIdx 和 newStartIdx ，真实 DOM 中的相应节点移到 Vnode 相应的位置，匹配上的两个指针向中间移动；</li>
<li>如果 oldEndIdx 和 newEndIdx 匹配上了，匹配上的两个指针向中间移动；</li>
<li>如果四种匹配没有一对是成功，那么会根据旧的 VNode 的 key 生成一张 hash 表，用 newStartIdx 的 key 与 hash 表做匹配，匹配成功就判断 newStartIdx 和匹配节点是否为 sameNode，如果是，就将真实 DOM 移到 oldStartIdx 前面，否则则说明当前索引下的新的 VNode 节点在旧的 VNode 队列中不存在，无法进行节点的复用，那么就只能调用 createElm 创建一个新的 DOM 节点放到当前 oldStartIdx 的位置。newStartIdx 指针向中间移动，被匹配 old 中的节点置为 null。</li>
</ol>
</li>
</ol>
<h3 id="案例演练"><a href="#案例演练" class="headerlink" title="案例演练"></a>案例演练</h3><p>假设以下所有节点都是有 key 的，且 key 为自身的值</p>
<ul>
<li>old:a-b-c-d</li>
<li>new:a-c-b-e-f</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oldStartIdx:a;</span><br><span class="line">oldEndIdx:d;</span><br><span class="line">newStartIdx:a</span><br><span class="line">newEndIdx:f</span><br><span class="line"></span><br><span class="line">oldStartIdx 和 newStartIdx 匹配，说明位置没变，此时 DOM 位置 a-b-c-d，此时指针：</span><br><span class="line"></span><br><span class="line">oldStartIdx: b;</span><br><span class="line">oldEndIdx: d;</span><br><span class="line">newStartIdx: c</span><br><span class="line">newEndIdx: f</span><br><span class="line"></span><br><span class="line">一个都没有匹配到，然后 c 匹配到旧的 VNode，将 c 放到 oldStartIdx前，此时 DOM 位置 a-c-b-d，此时指针：</span><br><span class="line"></span><br><span class="line">oldStartIdx: b;</span><br><span class="line">oldEndIdx: d;</span><br><span class="line">newStartIdx: b</span><br><span class="line">newEndIdx: f</span><br><span class="line"></span><br><span class="line">oldStartIdx 和 newStartIdx 匹配，说明位置没变，此时 DOM 位置 a-c-b-d，此时指针：</span><br><span class="line"></span><br><span class="line">oldStartIdx: d;</span><br><span class="line">oldEndIdx: d;</span><br><span class="line">newStartIdx: e</span><br><span class="line">newEndIdx: f</span><br><span class="line"></span><br><span class="line">一个都没有匹配到，然后 e 未匹配到旧的 VNode，将创建的 e 放到 oldStartIdx前，被匹配 old 中的节点置为 null。此时 DOM 位置 a-c-b-e</span><br><span class="line"></span><br><span class="line">遍历结束，说明旧的 VNode先遍历完。就将剩余的 VNode 节点根据自己的的index插入到真实DOM中去，此时 DOM 位置为：a-c-b-e-f</span><br><span class="line"></span><br><span class="line">一次模拟完成。</span><br><span class="line"></span><br><span class="line">这个匹配过程的结束有两个条件：</span><br><span class="line"></span><br><span class="line">1. oldStartIdx &gt; oldEndIdx 表示旧 VNode 先遍历完，那么就将多余的 VNode 根据index添加到DOM中去；</span><br><span class="line">2. newStartIdx &gt; newEndIdx 表示新 VNode 先遍历完，那么就在真实 DOM 中将区间为[oldStartIdx, oldEndIdx]的多余节点删掉</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://www.infoq.cn/article/uDLCPKH4iQb0cR5wGY7f">Vue 的 diff 算法解析</a></li>
<li><a href="https://juejin.im/post/6844903607913938951#heading-3">详解 Vue 的 diff 算法</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>diff</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 基础知识</title>
    <url>/2019/04/11/Vue%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>梳理一下 Vue 的基础知识。</p>
<span id="more"></span>

<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ol>
<li>created：Vue 实例创建完成，还未挂载</li>
<li>mounted：数据刚刚挂载到 Dom 上</li>
<li>beforedestroy：一般用于处理事件解绑，定时器清除</li>
</ol>
<h1 id="属性与计算属性"><a href="#属性与计算属性" class="headerlink" title="属性与计算属性"></a>属性与计算属性</h1><ol>
<li>访问 Vue 实例中的属性，可使用类似<code>vm.$el</code>的方式访问，访问 data 中的属性，直接使用<code>vm.xxx</code>的形式访问</li>
<li>文本插值<code>&#123;&#123;&#125;&#125;</code>，里面能进行简单的运算，不支持多行语句，复杂的数据使用计算属性，文本插值里可使用过滤器，<code>&#123;&#123;data | filterFunc&#125;&#125;</code></li>
<li>计算属性有缓存，其变更依赖其依赖属性的变更，计算属性可以计算多个 Vue 实例的数据</li>
<li>计算属性默认用的是 get 函数</li>
<li>methods 里的方法，没有缓存</li>
<li>class 的绑定，能同时使用对象和数组绑定，<code>:class=&quot;[&#123;xxx:true&#125;,yyy]&quot;</code></li>
</ol>
<h1 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h1><ol>
<li>v-cloak：解决初始化慢导致页面闪动的问题，一般和<code>display:none</code>一起使用</li>
<li>v-for：有一点，如果是遍历对象的多个属性，则用<code>value in obj</code>，如还要遍历 key 和 value 的值，则<code>(value,key,index) in obj</code> ,里面的顺序不能改变</li>
<li>数组的 push，pop，unshift，shift，splice，sort 和 reverse 等操作会改变数组，引发页面重新渲染，改变数组长度或者指定项不会。使用 Vue.set(items,index,newval) 和 items.splice(index,1,newval)，改变数组也会引发渲染</li>
<li>方法有参数，却不加括号，默认传的是原生 JavaScript 的事件对象</li>
<li>单个单选框，radio， 使用 v-model 不生效<br>6 checkbox：最好使用数组当做绑定值，如果不是，则会被转换成布尔值，使得 checkbox 全选或者全不选</li>
<li>select：只能把 v-model 放在 select</li>
<li>如果想 v-model 动态绑定值，使用 v-bind 绑定 value，v-model 的值是 value 的值</li>
</ol>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/">Vue</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex 小记</title>
    <url>/2019/04/02/Vuex%20%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<span id="more"></span>

<p>简单的数据共享可以用 eventBus，复杂的可以选择用 Vuex。</p>
<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：</p>
<p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>state 里存储的是状态（数据），当需要生成多个状态时，可使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">...mapState[<span class="string">&#x27;state1&#x27;</span>,<span class="string">&#x27;state2&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：</p>
<h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>类似计算属性，使用 Getter 获取 state 里的状态。mapGetters 辅助函数可将 store 中的 getter 映射到局部计算属性中。</p>
<h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>提交 mutation 是改变 Vuex 状态的唯一方法。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。使用 <code>store.commit(&#39;increment&#39;)</code> 这种形式调用一个 mutation handler。注意 Mutation 必须是同步函数，异步的可以将其放在 Action 中。</p>
<p>在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 类似于 mutation，不同在于：</p>
<ol>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ol>
<p>Action 通过 store.dispatch 方法触发</p>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>当应用变得非常复杂时，store 对象就有可能变得相当臃肿。Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</p>
]]></content>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件间通信</title>
    <url>/2019/02/24/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>列举了 4 种组件间通信的形式</p>
<span id="more"></span>

<h1 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h1><h2 id="利用-props"><a href="#利用-props" class="headerlink" title="利用 props"></a>利用 props</h2><p>使用 props，父组件可以使用 props 向子组件传递数据。子组件在 props 上注册该属性，就可用像用 data 一样使用 props。</p>
<h2 id="利用-children"><a href="#利用-children" class="headerlink" title="利用$children"></a>利用$children</h2><p>注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。</p>
<h1 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h1><h2 id="使用-Vue-事件"><a href="#使用-Vue-事件" class="headerlink" title="使用 Vue 事件"></a>使用 Vue 事件</h2><pre><code>发布订阅模式

1. 父组件自定义事件并监听
2. 自组件通过点击等事件触发该事件（$emit）
3. 父组件监听到这个事件，并获得传来的数据
</code></pre>
<h2 id="使用-parent"><a href="#使用-parent" class="headerlink" title="使用$parent"></a>使用$parent</h2><pre><code>父实例，如果当前实例有的话。
</code></pre>
<h1 id="爷孙通信"><a href="#爷孙通信" class="headerlink" title="爷孙通信"></a>爷孙通信</h1><pre><code>依旧是使用发布订阅模式。通过子父，父爷层层向上通知事件。
</code></pre>
<h1 id="非父子组件、兄弟组件之间的数据传递"><a href="#非父子组件、兄弟组件之间的数据传递" class="headerlink" title="非父子组件、兄弟组件之间的数据传递"></a>非父子组件、兄弟组件之间的数据传递</h1><p>使用 eventBus，利用 Vue 实例提供的 $emit 和 $on 方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> eventHub = <span class="keyword">new</span> Vue()</span></span><br><span class="line"><span class="javascript">  Vue.prototype.$eventHub = eventHub</span></span><br><span class="line"><span class="javascript">  <span class="comment">//compontent 是 Vue 的一个实例 this.__proto===Vue.prototype</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;component-a&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">        &lt;div&gt;a&lt;button @click=notify&gt;点击&lt;/button&gt;&lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">    `</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$eventHub.$emit(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;component-b&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">        &lt;div&gt;b&lt;div ref=output&gt;&lt;/div&gt;&lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">    `</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$eventHub.$on(<span class="string">&#x27;xxx&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$refs.output.textContent = data</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="更复杂的单页应用数据管理"><a href="#更复杂的单页应用数据管理" class="headerlink" title="更复杂的单页应用数据管理"></a>更复杂的单页应用数据管理</h1><p><a href="https://jiangnana.fun/2019/04/02/Vuex-%E5%B0%8F%E8%AE%B0/">请使用 Vuex</a></p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://cn.vuejs.org/">渐进式<br>JavaScript 框架</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>express 初识</title>
    <url>/2019/05/01/express%20%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>最近在使用 express 做在线备忘贴的小项目，一边摸索着使用，一边整理一下使用过程中的笔记。</p>
<span id="more"></span>

<h1 id="EXPRESS-的安装使用"><a href="#EXPRESS-的安装使用" class="headerlink" title="EXPRESS 的安装使用"></a>EXPRESS 的安装使用</h1><ol>
<li>安装 <code>npm i express</code>，一般使用第二种脚手架安装</li>
<li>安装 express 的脚手架 express-generator ：<code>npm install express-generator</code>，运行，<code>./node_modules/express-generator/bin/express-cli.js -f -e</code></li>
<li>运行 <code>npm i</code>，安装脚手架提供的包</li>
<li>运行 <code>PORT = 4000 node ./bin/www</code> 可以在端口 4000 预览 demo</li>
<li><code>&quot;start&quot;: &quot;cross-env PORT=8080 node ./bin/www&quot;</code>，可以设置脚本，默认在 8080 端口打开页面，cross-env 是为了解决 windows 下报错的问题。</li>
</ol>
<h1 id="EXPRESS-工作流程"><a href="#EXPRESS-工作流程" class="headerlink" title="EXPRESS 工作流程"></a>EXPRESS 工作流程</h1><p>目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── app.js # 应用的主入口</span><br><span class="line">├── bin  # 启动脚本</span><br><span class="line">├── node_modules # 依赖的模块</span><br><span class="line">├── package.json # node模块的配置文件</span><br><span class="line">├── public # 静态资源，如css、js等存放的目录</span><br><span class="line">├── routes # 路由规则存放的目录</span><br><span class="line">└── views # 模板文件存放的目录</span><br></pre></td></tr></table></figure>

<p>首先通过入口 <code>app.js</code>， 得到路由，路由一般会被拆分到 <code>routes/</code> 目录下，根据不同路由 render 数据到页面模板中。</p>
<h1 id="EXPRESS-三个重要的概念"><a href="#EXPRESS-三个重要的概念" class="headerlink" title="EXPRESS 三个重要的概念"></a>EXPRESS 三个重要的概念</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>顾名思义，负责寻址的，根据用户请求的定位资源，图片、样式等文件的路由走 static</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>进行数据处理，把请求交给中间键处理，得到的结果再给下一级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 可以得到请求的相关信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Time:&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">  next() <span class="comment">// 交给下一层的中间件，或者直接send</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>模板引擎类似 <code>Vue</code> 中的 template ，express 可选的模板引擎有 jade ，ejs 等</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/chyingp/p/express-intro.html">Express 使用手记：核心入门</a></li>
</ul>
]]></content>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>fuck ie , ie 兼容相关</title>
    <url>/2022/11/02/fuck%20ie%20,%20ie%20%E5%85%BC%E5%AE%B9%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>IE 始终都在，无法逃避。不过辛亏有各种 Babel 帮我们处理 IE 兼容问题。</p>
<p>目前只处理兼容 ie10 及以上。</p>
<span id="more"></span>

<h3 id="Echarts-兼容"><a href="#Echarts-兼容" class="headerlink" title="Echarts 兼容"></a>Echarts 兼容</h3><p>新版本的 Echarts5.0 对 ie 兼容有问题，降版本处理，如果使用 vue-echarts 也需要降版本。注意参数、方法变更，比如 5.0 版本 options 字段改成了 option。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;echarts&quot;: &quot;4.1.0&quot;,</span><br><span class="line">&quot;vue-echarts&quot;: &quot;4.0.2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Vue-cli-兼容"><a href="#Vue-cli-兼容" class="headerlink" title="Vue cli 兼容"></a>Vue cli 兼容</h3><p>cli 版本 5.0</p>
<p>.browserslistrc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 1%</span><br><span class="line">last 2 versions</span><br><span class="line">not ie &lt;= 10</span><br></pre></td></tr></table></figure>

<p>vue cli 有 babel 插件 <code>@vue/cli-plugin-babel</code>，需要配置一下：</p>
<p>babel.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">presets: [</span><br><span class="line">   [</span><br><span class="line">     &#x27;@vue/app&#x27;,</span><br><span class="line">     &#123;</span><br><span class="line">       polyfills: [&#x27;es.promise&#x27;, &#x27;web.url&#x27;, &#x27;web.url-search-params&#x27;],</span><br><span class="line">     &#125;,</span><br><span class="line">   ],</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>

<p>以上，后续有再补充。</p>
]]></content>
      <tags>
        <tag>IE</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title>mixin、科里化，高阶函数</title>
    <url>/2019/03/09/mixin%E3%80%81%E7%A7%91%E9%87%8C%E5%8C%96%EF%BC%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>了解一下一些 mixin、柯里化、高阶函数。</p>
<span id="more"></span>

<h1 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h1><p>用代码解释一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> b) &#123;</span><br><span class="line">        a[key] = b[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码能完成把对象 b 中的属性全部覆盖到 a 中。</p>
<p>ES6 中 Object.assign 也是同样的功能</p>
<h1 id="柯里化-currying"><a href="#柯里化-currying" class="headerlink" title="柯里化 currying"></a>柯里化 currying</h1><p>说到柯里化，就有必要说一下 bind() 方法。</p>
<p>bind 方法将函数绑定到一个对象，它还附带一些其他应用：除了第一个实参之外，传入 bind() 的实参也会绑定到 this。</p>
<p>这个附带应用有时也被称为“柯里化”</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类似sum的新函数，但 this 的值是 null</span></span><br><span class="line"><span class="comment">// 并且第一个参数绑定到1，这个新函数期望只传入一个实参</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line">succ(<span class="number">2</span>) <span class="comment">// 3 x绑定到1，并传入2作为实参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">2</span>) <span class="comment">// 绑定this和y</span></span><br><span class="line">g(<span class="number">3</span>) <span class="comment">// 6 this.x绑定到1，y绑定2，z绑定3</span></span><br></pre></td></tr></table></figure>

<p>简单的来说，柯里化是将函数中一个或多个变量设为定值，并得到一个新函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = []</span><br><span class="line"><span class="comment">// 当add没传参数时，返回之前传入参数之和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.reduce(<span class="function">(<span class="params">i, j</span>) =&gt;</span> i + j, <span class="number">0</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cache.push(n)</span><br><span class="line">    <span class="keyword">return</span> add</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)() <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进阶版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn_args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(fn_args))</span><br><span class="line">  &#125;</span><br><span class="line">  fn.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>所谓高阶函数 higher-order function ，就是操作函数的函数。它接收一个或多个函数作为参数，并返回一个新函数。</p>
<p>比如 bind() 也可以实现高阶函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动调用bind</span></span><br><span class="line">add2 = <span class="built_in">Function</span>.prototype.bind.call(add1, <span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">//将add1传入，this的值绑定到undefined，x的值绑定到1</span></span><br><span class="line"></span><br><span class="line">add2(<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>mixin</tag>
        <tag>柯里化</tag>
        <tag>高阶函数</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>render函数</title>
    <url>/2019/04/16/render%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。</p>
<span id="more"></span>

<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>template</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;hdom&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;level==1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;level==2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;level==3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 vue 组件定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;level&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;#hdom&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 render 函数进行定义组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;h&#x27;</span> + <span class="built_in">this</span>.level, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;level&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="render-函数的参数"><a href="#render-函数的参数" class="headerlink" title="render 函数的参数"></a>render 函数的参数</h1><ol>
<li>第一个参数必须是 createElement,该参数的类型是 function</li>
</ol>
<h1 id="createElement-函数的参数"><a href="#createElement-函数的参数" class="headerlink" title="createElement 函数的参数"></a>createElement 函数的参数</h1><h2 id="第一个参数（必选）"><a href="#第一个参数（必选）" class="headerlink" title="第一个参数（必选）"></a>第一个参数（必选）</h2><p>有三种数据类型</p>
<ol>
<li>String 类型：HTML 标签，例如<code>h1</code></li>
<li>Object 类型：含有数据的对象，如<code>&#123;template: &quot;&lt;h1&gt;&lt;/h1&gt;&quot;&#125;</code></li>
<li>Function 类型：返回一个数据对象，例如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">createElement</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;&lt;h1&gt;13&lt;/h1&gt;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createElement(dom(), <span class="built_in">this</span>.$slots.default)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="第二个参数（可选）"><a href="#第二个参数（可选）" class="headerlink" title="第二个参数（可选）"></a>第二个参数（可选）</h2><p>数据对象，只能是 Object</p>
<p>常用的选项有：</p>
<ol>
<li>class</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>:</span>&#123;</span><br><span class="line">  <span class="attr">xxx</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>style</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">style: &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>attrs （正常的 html 特性）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attrs:&#123;</span><br><span class="line">  id:&#x27;xxx&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>domprops （原生 Dom 特性）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">domProps:&#123;</span><br><span class="line">  innerHTML:&#x27;&lt;strong&gt;我是加粗的字&lt;/strong&gt;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>on 添加事件监听</li>
</ol>
<h2 id="第三个参数（可选）"><a href="#第三个参数（可选）" class="headerlink" title="第三个参数（可选）"></a>第三个参数（可选）</h2><p>可以是 String 或 Array 类型，代表子节点</p>
<ol>
<li>String 类型：</li>
<li>Array 类型：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params">createElement</span>)</span> &#123;</span><br><span class="line">				<span class="keyword">let</span> xxx = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> &#123;</span><br><span class="line">						<span class="attr">template</span>: <span class="string">&quot;&lt;h1&gt;&lt;/h1&gt;&quot;</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> createElement(</span><br><span class="line">					<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line"></span><br><span class="line">						<span class="attr">attrs</span>: &#123;</span><br><span class="line">							<span class="attr">id</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">						&#125;,</span><br><span class="line">						<span class="attr">style</span>: &#123;</span><br><span class="line">							<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">						&#125;,</span><br><span class="line">						<span class="attr">class</span>: &#123;</span><br><span class="line">							<span class="attr">x1xxx</span>: <span class="literal">true</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;,[</span><br><span class="line">						createElement(<span class="string">&#x27;div&#x27;</span>,<span class="string">&#x27;div内容1&#x27;</span>),</span><br><span class="line">						createElement(<span class="string">&#x27;div&#x27;</span>,<span class="string">&#x27;div内容2&#x27;</span>)</span><br><span class="line">					]</span><br><span class="line">				);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h1 id="slot-在-render-中应用"><a href="#slot-在-render-中应用" class="headerlink" title="slot 在 render 中应用"></a>slot 在 render 中应用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&#x27;a&#x27;</span>&gt;</span>333<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&#x27;b&#x27;</span>&gt;</span>444<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">render</span>(<span class="params">createElement</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> header = <span class="built_in">this</span>.$slots.a <span class="comment">// 返回含有 VNODE 的数组</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> main = <span class="built_in">this</span>.$slots.default</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> footer = <span class="built_in">this</span>.$slots.b</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> createElement(</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="string">&#x27;div&#x27;</span>,[</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          createElement(<span class="string">&#x27;header&#x27;</span>,header),<span class="comment">// 虚拟节点，因为 vue 的双向绑定，每次更新了虚拟节点的数据，页面就会更新变更的那一部分</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          createElement(<span class="string">&#x27;main&#x27;</span>,main),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          createElement(<span class="string">&#x27;footer&#x27;</span>,footer)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        ]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      );</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">data</span>: &#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="作用域插槽在-render-中的应用"><a href="#作用域插槽在-render-中的应用" class="headerlink" title="作用域插槽在 render 中的应用"></a>作用域插槽在 render 中的应用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span> = <span class="string">&#x27;my&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;&#123;my.xxx&#125;&#125;</span></span><br><span class="line"><span class="xml">      &#123;&#123;my.yyy&#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">render</span>(<span class="params">createElement</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> createElement(</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="string">&#x27;div&#x27;</span>,<span class="built_in">this</span>.$scopedSlots.default(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">xxx</span>:<span class="string">&#x27;111&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">yyy</span>:<span class="string">&#x27;222&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      );</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">data</span>: &#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="函数化组件"><a href="#函数化组件" class="headerlink" title="函数化组件"></a>函数化组件</h1><p>设置 <code>functional:true</code> ,则该组件无状态，无实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;child value=&quot;hi&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  Vue.component(&#x27;child&#x27;, &#123;</span><br><span class="line">    functional:true,</span><br><span class="line">    render(createElement,context) &#123;</span><br><span class="line"></span><br><span class="line">      return createElement(</span><br><span class="line">        &#x27;div&#x27;,[</span><br><span class="line">          createElement(&#x27;button&#x27;,&#123;</span><br><span class="line">            on:&#123;</span><br><span class="line">              click:function()&#123;</span><br><span class="line">                console.log(context.parent) // 父组件</span><br><span class="line">                console.log(context.props.value) // hi</span><br><span class="line">                console.log(context.children) // 子组件</span><br><span class="line">                console.log(this) // Window</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#x27;点击&#x27;)</span><br><span class="line">        ]</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  let vm = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/render-function.html">渲染函数 &amp; JSX</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>render</tag>
      </tags>
  </entry>
  <entry>
    <title>var,let,const之间的区别</title>
    <url>/2019/03/02/var,let,const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>首先声明变量都放在作用域第一行！然后再写一下 var,let,const 之间的区别。</p>
<span id="more"></span>

<h1 id="var"><a href="#var" class="headerlink" title="var"></a>var</h1><p>var 在 mdn 中是被这描述的：</p>
<p>变量声明，无论发生在何处，即使代码未执行，都在执行任何代码之前进行处理。</p>
<p>将赋值给未声明变量的值在执行赋值时将其<strong>隐式地创建为全局变量</strong>（它将成为全局对象的属性）。但有时也不一定如此，有时多层嵌套函数时，如果上一层声明了 a，内部使用 a 就不会生成全局变量。</p>
<p>声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建</p>
<p>未能声明变量将很可能导致意想不到的结果。因此，建议始终声明变量，无论它们是在函数还是全局作用域内。 在 ECMAScript 5 严格模式下，分配给未声明的变量会引发错误。</p>
<p>由于变量提升，变量可以在其声明之前使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 5</span><br><span class="line">var a</span><br><span class="line"></span><br><span class="line">//可以理解为</span><br><span class="line"></span><br><span class="line">var a</span><br><span class="line">a = 5</span><br></pre></td></tr></table></figure>

<p>因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域（本地），哪些变量在作用域链上的。</p>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><p>let 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与 var 关键字不同的是，var 声明的变量只能是全局或者整个函数块的。</p>
<p>let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。</p>
<p>在 let 声明变量前使用该变量会报错（Temp Dead Zooe）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span> <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span> <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在(同一个函数或)同一个作用域中用 let 重复定义一个变量将引起 TypeError。</p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const 是块级作用域，很像使用 let 语句定义的变量。const 的值不能通过重新赋值来改变，并且不能重新声明。</p>
<p>const 创建一个常数，这个常数可以是全局的或者是局部的。 全局的常量不能成为<code>window</code>的属性，不像<code>var</code>。</p>
<p>const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。</p>
<p>常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var">var mdn</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let">let mdn</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const">const mdn</a></li>
</ul>
]]></content>
      <tags>
        <tag>var</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>vw、rem 混合适配移动端与PC端</title>
    <url>/2023/03/11/vw%E3%80%81rem%20%E6%B7%B7%E5%90%88%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8EPC%E7%AB%AF/</url>
    <content><![CDATA[<p>目前移动端有两种适配方案，一种是传统的 rem 布局，需要在页面中加入一段js代码，用于计算根元素的 <code>font-size</code>，另外一种则是使用 vw 单位，不用使用js。</p>
<span id="more"></span>

<p>两种方案，主流是vw，因为不用额外在页面中加入js，但是该方案在 PC 端就非常不友好，因为vw是取决于页面的宽度，加上PC端是横屏的，就会导致页面内容被放大，对用户非常不友好。</p>
<p>如果是纯粹移动端访问的，那问题不大，直接找个可以 px 转 vw 插件 <code>postcss-px-to-viewport-8-plugin</code>，自动转单位就好了。</p>
<p>如果想移动端（页面宽度小于750px）自动适配，大于750px就固定大小的，可以使用 <code>媒体查询 + rem + vw</code> 进行适配；</p>
<p>考虑到根元素 <code>font-size</code> 有最小值，而设计稿也有 375px 宽度的，计算后的 <code>font-size</code> 单位太小，在低版本浏览器有显示问题，需要放大根元素的 <code>font-size</code>；</p>
<p>话不多说，直接上代码。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">750px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">4vw</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大于750px就居中显示 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">750px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">750px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;postcss-px-to-viewport-8-plugin&#x27;</span>)(&#123;</span><br><span class="line">      <span class="attr">unitToConvert</span>: <span class="string">&#x27;px&#x27;</span>,</span><br><span class="line">      <span class="attr">viewportWidth</span>: <span class="number">375</span>*<span class="number">4</span>, <span class="comment">// 设计稿 放大4倍，css那也要放大4倍。</span></span><br><span class="line">      <span class="attr">unitPrecision</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="attr">propList</span>: [<span class="string">&#x27;*&#x27;</span>],</span><br><span class="line">      <span class="attr">viewportUnit</span>: <span class="string">&#x27;rem&#x27;</span>,</span><br><span class="line">      <span class="attr">fontViewportUnit</span>: <span class="string">&#x27;rem&#x27;</span>,</span><br><span class="line">      <span class="attr">selectorBlackList</span>: [<span class="string">&#x27;.ignore&#x27;</span>, <span class="string">&#x27;.hairlines&#x27;</span>],</span><br><span class="line">      <span class="attr">minPixelValue</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">mediaQuery</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">replace</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">landscape</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">landscapeUnit</span>: <span class="string">&#x27;rem&#x27;</span>,</span><br><span class="line">      <span class="attr">landscapeWidth</span>: <span class="number">667</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>移动端</tag>
        <tag>vw</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title>web 性能优化</title>
    <url>/2019/03/10/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>从网页开始请求到加载完成，从前端角度分析如何实现 web 性能优化，即：网页加载更快。</p>
<span id="more"></span>

<p>网页开始请求到加载完成可分为以下几个过程：</p>
<ol>
<li>本地缓存 <code>×</code> 第一次访问没有缓存</li>
<li>DNS 缓存 <code>√</code></li>
<li>建立 TCP 连接 <code>√</code></li>
<li>发送请求 <code>√</code></li>
<li>后台处理 <code>×</code> 前端无法处理</li>
<li>接收响应 <code>√</code></li>
<li>接收完成 <code>√</code></li>
<li>解读 DOCTYPE <code>√</code></li>
<li>逐行解析 <code>√</code></li>
<li>解析标签 <code>√</code></li>
<li>解析 CSS <code>√</code></li>
<li>解析 JS <code>√</code></li>
</ol>
<h1 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h1><p>网页中的域名需要经过域名解析，而一次解析就要 20-120 ms 的时间。在 dns 查询结束之前，浏览器不会下载该域名下的任何东西。所以减少 dns 查询的时间可以加快页面的加载速度。建议一个页面所包含的域名数尽量控制在 2-4 个。</p>
<h1 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h1><p>Keep-Alive 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。</p>
<p>建立 TCP 连接首先需要三次握手，在传输数据之前，在客户端和服务器之间相互交换 SYN 和 ACK 数据包。使用 keep-alive 标头意味着不必经常执行此过程。好处有：</p>
<ul>
<li>网络资源保护：每个客户端使用单个连接对网络资源的负担较小。</li>
<li>减少网络拥塞：减少服务器和客户端之间的 TCP 连接数可能会导致网络拥塞减少。</li>
<li>减少延迟：减少三方握手次数可以改善网站延迟。对于 SSL / TLS 连接尤其如此，这需要额外的往返来加密和验证连接。</li>
</ul>
<p>HTTP/2 中使用的是多路复用。</p>
<p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制。</p>
<p>在 HTTP/2 中：</p>
<p>同域名下所有通信都在单个连接上完成。单个连接可以承载任意数量的双向数据流。数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p>
<p>这一特性，使性能有了极大提升：</p>
<p>同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。<br>单个连接上可以并行交错的请求和响应，之间互不干扰。<br>在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</p>
<h1 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h1><p>因为浏览器每次发送请求都会带上 cookie ，因此减少 cookie 的大小可以加快请求速度。并使用 cache-control。倘若文件过大，就分多次请求，避免用户一次等待过多时间。这是就需要多个域名，增大瞬间请求的数量。</p>
<h1 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h1><ol>
<li>使用 Etag，倘若服务器内容未更新，则服务器返回 304.</li>
<li>使用 Gzip 压缩。服务器把响应内容压缩后再传输，浏览器重新解压后再使用数据。</li>
</ol>
<h1 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h1><p>doctype 写错可能导致页面显示不正常，并且不能不写。</p>
<h1 id="逐行解析"><a href="#逐行解析" class="headerlink" title="逐行解析"></a>逐行解析</h1><p>尽量减少标签数量</p>
<h1 id="解析标签"><a href="#解析标签" class="headerlink" title="解析标签"></a>解析标签</h1><p>解析到标签，比如<code>h1</code></p>
<p>在 ie 中会直接显示便签，在解析到 CSS 后再重新渲染标签，影响性能</p>
<p>在 Chrome 中，浏览器默认用户是在网速很快的环境下的，因此是等到 css 加载完毕再显示标签</p>
<h1 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h1><ol>
<li>尽量少的 CSS 以减少请求数量。</li>
<li>将 CSS 放到页面首部，某些浏览器就不用重载页面。</li>
<li>压缩文件大小</li>
</ol>
<h1 id="解析-js"><a href="#解析-js" class="headerlink" title="解析 js"></a>解析 js</h1><ol>
<li>js 脚本文件放到页面底部，因为脚本文件会阻塞页面加载</li>
<li>尽量减少的 js 以减少请求数量。</li>
<li>压缩文件大小。</li>
<li>懒加载，先加载用户时候的数据，当用户滚动的时候再加载下面的。</li>
<li>加 loading 动画可以延长用户等待时间。</li>
<li>将 js 和 CSS 文件放到 CDN 上，速度快，而且都是无 cookie 请求。</li>
</ol>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive">Keep-Alive</a></li>
<li><a href="https://www.incapsula.com/cdn-guide/glossary/http-keep-alive.html">What is HTTP Keep-Alive</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26559480">一文读懂 HTTP/2 特性</a></li>
</ul>
]]></content>
      <tags>
        <tag>性能</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>三种常见排序</title>
    <url>/2019/04/01/%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>好记性不如烂笔头，万一哪天忘了，我还能查…</p>
<span id="more"></span>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><img src="https://www.google.com/url?sa=i&source=images&cd=&cad=rja&uact=8&ved=2ahUKEwiGmdamh6_hAhVBCqYKHcNsD-0QjRx6BAgBEAU&url=https://www.cnblogs.com/eniac12/p/5329396.html&psig=AOvVaw0xPQB8eNXUhz08vcurfcT5&ust=1554213666476354" alt="冒泡排序"></p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = array.length,</span><br><span class="line">    j,</span><br><span class="line">    temp</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = array[j]</span><br><span class="line">        array[j] = array[j + <span class="number">1</span>]</span><br><span class="line">        array[j + <span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="选择排序"></p>
<h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ol>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = array.length,</span><br><span class="line">    i,</span><br><span class="line">    j,</span><br><span class="line">    minIndex,</span><br><span class="line">    minValue,</span><br><span class="line">    temp</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">    minValue = array[minIndex]</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &lt; minValue) &#123;</span><br><span class="line">        minIndex = j</span><br><span class="line">        minValue = array[minIndex]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换位置</span></span><br><span class="line">    temp = array[i]</span><br><span class="line">    array[i] = minValue</span><br><span class="line">    array[minIndex] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="快速排序"></p>
<h2 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h2><ol>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ol>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 交换元素位置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = array[i]</span><br><span class="line">    array[i] = array[k]</span><br><span class="line">    array[k] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组分区，左小右大</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> storeIndex = left</span><br><span class="line">    <span class="keyword">var</span> pivot = array[right] <span class="comment">// 直接选最右边的元素为基准元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">        swap(array, storeIndex, i)</span><br><span class="line">        storeIndex++ <span class="comment">// 交换位置后，storeIndex 自增 1，代表下一个可能要交换的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, right, storeIndex) <span class="comment">// 将基准元素放置到最后的正确位置上</span></span><br><span class="line">    <span class="keyword">return</span> storeIndex</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> storeIndex = partition(array, left, right)</span><br><span class="line">    sort(array, left, storeIndex - <span class="number">1</span>)</span><br><span class="line">    sort(array, storeIndex + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/">常见排序算法 - 冒泡排序 (Bubble Sort)</a></li>
<li><a href="http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/">常见排序算法 - 选择排序 (Selection Sort)</a></li>
<li><a href="http://bubkoo.com/2014/01/12/sort-algorithm/quick-sort/">常见排序算法 - 快速排序 (Quick Sort)</a></li>
</ul>
]]></content>
      <tags>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>个性化 echarts 图表</title>
    <url>/2019/06/29/%E4%B8%AA%E6%80%A7%E5%8C%96echarts/</url>
    <content><![CDATA[<p>最近公司开发 ERP 系统，其中有表格展示，一开始也没放在心上，心想用 echarts 就行了，但真正开始做后，才发现 echarts 并不简单。</p>
<span id="more"></span>

<p>其中有一张表的需求是这样的：横坐标表示门店，纵坐标表示门店的销售额和预期销售额，超过预期，超过的部分用紫色表示，未达到预期，未完成的部分用红色表示。</p>
<p>由于对 echarts 不熟悉，一开始就想用堆叠柱状图表示，一部分是实际完成的销售额，一部分是超过的数据，超过的数据有正负，正值表示超过预期了，负值表示低于预期，结果展示出来是这样的</p>
<p>配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;shop1&#x27;</span>, <span class="string">&#x27;shop2&#x27;</span>, <span class="string">&#x27;shop3&#x27;</span>, <span class="string">&#x27;shop4&#x27;</span>, <span class="string">&#x27;shop5&#x27;</span>, <span class="string">&#x27;shop5&#x27;</span>, <span class="string">&#x27;shop6&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">formatter</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;value&#125;</span> 万元`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tooltip</span>: &#123;</span><br><span class="line">    <span class="attr">trigger</span>: <span class="string">&#x27;axis&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;预期销售额&#x27;</span>,</span><br><span class="line">      <span class="attr">stack</span>: <span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">120</span>, <span class="number">200</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">110</span>, <span class="number">130</span>],</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;完成情况&#x27;</span>,</span><br><span class="line">      <span class="attr">stack</span>: <span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">12</span>, <span class="number">20</span>, <span class="number">15</span>, -<span class="number">8</span>, <span class="number">7</span>, -<span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> p.value &gt;= <span class="number">0</span> ? <span class="string">&#x27;purple&#x27;</span> : <span class="string">&#x27;red&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展示出来的效果：</p>
<p><img src="https://i.loli.net/2019/06/29/5d1712ca9761120404.png" alt="初始图表"></p>
<p>发现了几个问题，</p>
<ol>
<li>完成情况的值，应该是预期目标值+超过的数据，而不只是超出的数据；</li>
<li>色块的位置，应该都在顶部的；</li>
<li>两个色块叠加的高度，应该等于实际完成的销售额。</li>
</ol>
<p>基于此，分析数据，然后得到解决方法：</p>
<ol>
<li>判断超出数据的值，如果为负，则预期目标值为（预期目标值-未达到的值），并记录下该数值的索引，将负值取正；</li>
<li>正常堆叠，但是鼠标悬浮上去的值，如果是正值的索引，预期目标值不变，实际完成是预期目标值+超出的数据，如果是负值的索引，两者的值互换位置；</li>
<li>对的色块也要根据索引改变颜色。</li>
</ol>
<p>说的有些费劲，还是上代码吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data1 = [120, 200, 150, 80, 70, 110, 130]</span><br><span class="line">let data2 = [12, 20, 15, -8, 7, -11, 13]</span><br><span class="line">let indexes = []</span><br><span class="line"></span><br><span class="line">data2.forEach((v,k)=&gt;&#123;</span><br><span class="line">    if(v&lt;0)&#123;</span><br><span class="line">        indexes.push(k)</span><br><span class="line">        data1[k] =  data1[k]+v</span><br><span class="line">        data2[k] =  Math.abs(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">option = &#123;</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        type: &#x27;category&#x27;,</span><br><span class="line">        data: [&#x27;shop1&#x27;, &#x27;shop2&#x27;, &#x27;shop3&#x27;, &#x27;shop4&#x27;, &#x27;shop5&#x27;, &#x27;shop5&#x27;, &#x27;shop6&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: &#x27;value&#x27;,</span><br><span class="line">        axisLabel: &#123;</span><br><span class="line">                formatter(value) &#123;</span><br><span class="line">                  return `$&#123;value&#125; 万元`;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">     tooltip :&#123;</span><br><span class="line">            trigger: &quot;axis&quot;,</span><br><span class="line">            formatter(value) &#123;</span><br><span class="line">              if (indexes.indexOf(value[0].dataIndex) &gt;= 0) &#123;</span><br><span class="line">                return `</span><br><span class="line">              $&#123;value[0].name&#125;&lt;br/&gt;</span><br><span class="line">              $&#123;value[0].marker&#125;$&#123;value[0].seriesName&#125;: $&#123;value[0].data +</span><br><span class="line">                  value[1].data&#125;&lt;br /&gt;</span><br><span class="line">              $&#123;value[1].marker&#125;$&#123;value[1].seriesName&#125;: $&#123;value[0].data&#125;</span><br><span class="line">              `;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                return `</span><br><span class="line">              $&#123;value[0].name&#125;&lt;br/&gt;</span><br><span class="line">              $&#123;value[0].marker&#125;$&#123;value[0].seriesName&#125;: $&#123;value[0].data&#125;&lt;br /&gt;</span><br><span class="line">              $&#123;value[1].marker&#125;$&#123;value[1].seriesName&#125;: $&#123;value[0].data +</span><br><span class="line">                  value[1].data&#125;</span><br><span class="line">              `;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        name:&#x27;预期销售额&#x27;,</span><br><span class="line">        stack:&#x27;one&#x27;,</span><br><span class="line">        data: data1,</span><br><span class="line">        type: &#x27;bar&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name:&#x27;完成情况&#x27;,</span><br><span class="line">        stack:&#x27;one&#x27;,</span><br><span class="line">        data: data2,</span><br><span class="line">        type: &#x27;bar&#x27;,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">                color: function(p) &#123;</span><br><span class="line">                  return  indexes.indexOf(p.dataIndex) &gt;= 0 ? &quot;red&quot; : &quot;purple&quot;;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>预览效果如下：</p>
<p><img src="https://i.loli.net/2019/06/29/5d1721c76600393971.png" alt="最终图表"></p>
<p>有点 low ，不过大体完成效果~~</p>
]]></content>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>事件委托</title>
    <url>/2019/03/17/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p>现页面有<code>&lt;li&gt;</code>若干个，倘若需要监听每个<code>&lt;li&gt;</code>，传统的方法是遍历标签，并给它们添加同样多的点击事件，但如果页面中有多个标签，给每个标签都添加点击事件，会造成内存占用过多。今天利用事件捕获冒泡机制，写一个事件委托，解决这个问题。</p>
<span id="more"></span>

<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>03<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>04<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>05<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>06<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oUl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">oUl.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ele =  e.target</span><br><span class="line">    <span class="keyword">while</span> (!ele.matches(<span class="string">&#x27;li&#x27;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(ele.matches(<span class="string">&#x27;ul&#x27;</span>))&#123;</span><br><span class="line">            ele = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        ele = ele.parentNode  <span class="comment">// 一直往上寻找父元素，直到ul退出循环、</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ele &amp;&amp; ele.style.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h1><p>简单的说，事件分为捕获和冒泡阶段。当<code>addEventListener</code>设置为 true 时，监听捕获时的事件，当设置为 false 时，监听冒泡时的阶段，默认是使用冒泡。如果在目标上捕获和冒泡都有监听，则按照书写顺序依次执行。</p>
<p>举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当点击c时, 输出结果：c b a</span></span><br><span class="line">a.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">b.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&#125;)<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">// 当点击c时,先捕获，再冒泡，因此输出结果：b c a</span></span><br><span class="line"><span class="string">a.addEventListener(&#x27;click&#x27;,function()&#123;</span></span><br><span class="line"><span class="string">  console.log(&#x27;a&#x27;)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">b.addEventListener(&#x27;click&#x27;,function()&#123;</span></span><br><span class="line"><span class="string">  console.log(&#x27;b&#x27;)</span></span><br><span class="line"><span class="string">&#125;,true)</span></span><br><span class="line"><span class="string">c.addEventListener(&#x27;click&#x27;,function()&#123;</span></span><br><span class="line"><span class="string">  console.log(&#x27;c&#x27;)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>事件委托</tag>
        <tag>冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找如何定位左边界和右边界</title>
    <url>/2021/06/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%B7%A6%E8%BE%B9%E7%95%8C%E5%92%8C%E5%8F%B3%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<p>不使用 JS 数组 API，查找<code>有序</code>数列最先出现的位置和最后出现的位置</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left1 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = arr.length</span><br><span class="line">  <span class="keyword">while</span> (left1 &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((right + left1) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) left1 = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr[left1] !== target) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">start</span>: -<span class="number">1</span>, <span class="attr">end</span>: -<span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> left2 = left1</span><br><span class="line">  right = arr.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left1 &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((right + left1) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] === target) left1 = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">start</span>: left2, <span class="attr">end</span>: left1 - <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">binarySearch(a, <span class="number">5</span>) <span class="comment">// &#123;start: 2, end: 8&#125;</span></span><br><span class="line">binarySearch(a, <span class="number">7</span>) <span class="comment">// &#123;start: 9, end: 10&#125;</span></span><br><span class="line">binarySearch(a, <span class="number">47</span>) <span class="comment">// &#123;start:-1, end: -1&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/320">第 150 题：二分查找如何定位左边界和右边界 </a></li>
</ul>
]]></content>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法定位 Bug</title>
    <url>/2022/08/05/%E4%BA%8C%E5%88%86%E6%B3%95%E5%AE%9A%E4%BD%8D%20Bug/</url>
    <content><![CDATA[<p>二分法是 debug 中最常用也是最好用的方式。我们可以一点点注释掉程序逻辑，不断地进行排错，把可能出现的问题范围缩小，然后找出罪魁祸首。再用常规手段调试。</p>
<span id="more"></span>

<p>大概方法，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a()</span><br><span class="line">    b()</span><br><span class="line">    c()</span><br><span class="line">    d()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;cc&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如函数 <code>abcd</code> ，期望依次打印出 abcd，结果打印出 abccd ，使用二分法思路：</p>
<ol>
<li>先把函数 abcd 中，函数 c d 先注释，此时输出 ab，结果符合预期；</li>
<li>只注释函数 d ，此时输出 abcc，结果不符合预期；</li>
<li>发现函数c输出了 cc ，找到错误源头。</li>
</ol>
<p>上面例子很简单，但当项目复杂度上升，按照例子思路就可以一块一块确定代码块，快速定位 bug。</p>
]]></content>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是AJAX</title>
    <url>/2018/12/19/%E4%BB%80%E4%B9%88%E6%98%AFAJAX/</url>
    <content><![CDATA[<h1 id="什么是-AJAX"><a href="#什么是-AJAX" class="headerlink" title="什么是 AJAX"></a>什么是 AJAX</h1><p>1999 年，微软公司发布 IE 浏览器 5.0 版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到 2004 年 Gmail 发布和 2005 年 Google Map 发布，才引起广泛重视。2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。W3C 也在 2006 年发布了它的国际标准。</p>
<span id="more"></span>

<p>具体来说，AJAX 包括以下几个步骤。</p>
<ol>
<li>创建 XMLHttpRequest 实例</li>
<li>发出 HTTP 请求</li>
<li>接收服务器传回的数据</li>
<li>更新网页数据</li>
</ol>
<p>概括起来，就是一句话，<strong>AJAX 通过原生的 XMLHttpRequest 对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理</strong>。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url = option.url</span><br><span class="line">    <span class="keyword">let</span> method = option.method</span><br><span class="line">    <span class="keyword">let</span> body = option.body</span><br><span class="line">    <span class="keyword">let</span> success = option.success</span><br><span class="line">    <span class="keyword">let</span> fail = option.success</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> httpRquest = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    httpRquest.open(method, url)</span><br><span class="line">    httpRquest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (httpRquest.readyState === <span class="number">4</span> &amp;&amp; httpRquest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve.call(<span class="literal">undefined</span>, httpRquest.responseText)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (httpRquest.readyState === <span class="number">4</span> &amp;&amp; httpRquest.status === <span class="number">404</span>) &#123;</span><br><span class="line">        reject.call(<span class="literal">undefined</span>, httpRquest.response)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    httpRquest.send(body)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>只有 <strong>协议+端口+域名</strong> 一模一样才允许发 AJAX 请求</p>
<p>一模一样一模一样一模一样一模一样一模一样一模一样一模一样一模一样</p>
<pre><code>- http://baidu.com 可以向 http://www.baidu.com 发 AJAX 请求吗 no
- http://baidu.com:80 可以向 http://baidu.com:81 发 AJAX 请求吗 no
</code></pre>
<p>浏览器必须保证</p>
<p>只有 协议+端口+域名 一模一样才允许发 AJAX 请求</p>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS ( Cross-Origin Resource Sharing ) 可以告诉浏览器，我俩一家的，别阻止他。</p>
<p>具体来说，就是在后台设置的头信息之中，增加一个<code>Access-Control-Allow-Origin</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> port = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!port) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&#x27;</span>)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parsedUrl = url.parse(request.url, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">var</span> path = request.url</span><br><span class="line">  <span class="keyword">var</span> query = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (path.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    query = path.substring(path.indexOf(<span class="string">&#x27;?&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pathNoQuery = parsedUrl.pathname</span><br><span class="line">  <span class="keyword">var</span> queryObject = parsedUrl.query</span><br><span class="line">  <span class="keyword">var</span> method = request.method</span><br><span class="line"></span><br><span class="line">  <span class="comment">/******** 从这里开始看，上面不要看 ************/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> string = fs.readFileSync(<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> m = fs.readFileSync(<span class="string">&#x27;./db&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>) <span class="comment">//100</span></span><br><span class="line">    string = string.replace(<span class="string">&#x27;$$n$$&#x27;</span>, m)</span><br><span class="line">    response.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;charset=utf-8&#x27;</span>)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathNoQuery === <span class="string">&#x27;/count&#x27;</span> &amp;&amp; method.toUpperCase() === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    response.statusCode = <span class="number">200</span></span><br><span class="line">    <span class="keyword">var</span> m = fs.readFileSync(<span class="string">&#x27;./db&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    m = <span class="built_in">parseInt</span>(m, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> n = m + <span class="number">1</span></span><br><span class="line">    fs.writeFileSync(<span class="string">&#x27;./db&#x27;</span>, n)</span><br><span class="line">    response.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/json&#x27;</span>, <span class="string">&#x27;charset=utf-8&#x27;</span>)</span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8008&#x27;</span>) <span class="comment">//最重要的是这一句</span></span><br><span class="line">    response.write(<span class="string">`</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;count&quot;:&quot;<span class="subst">$&#123;n&#125;</span>&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.statusCode = <span class="number">404</span></span><br><span class="line">    response.write(<span class="string">&#x27;网页走丢了&#x27;</span>)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/******** 代码结束，下面不要看 ************/</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;127.0.0.1:&#x27;</span> + port)</span><br></pre></td></tr></table></figure>

<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP 只能 get，不够安全。<a href="https://jiangnana.fun/2018/12/18/%E4%BB%80%E4%B9%88%E6%98%AFJSONP/">什么是 JSONP &gt;&gt;</a></p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html">https://wangdoc.com/javascript/bom/xmlhttprequest.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是JSONP</title>
    <url>/2018/12/18/%E4%BB%80%E4%B9%88%E6%98%AFJSONP/</url>
    <content><![CDATA[<h3 id="什么是-JSONP"><a href="#什么是-JSONP" class="headerlink" title="什么是 JSONP"></a>什么是 JSONP</h3><p>请求方：浏览器（前端）</p>
<p>响应方：服务器（后端）</p>
<span id="more"></span>

<ol>
<li>浏览器动态创建<code>&lt;script&gt;</code>标签， src 指向响应方，并插入到<code>&lt;body&gt;</code>中，同时传一个查询参数（ url?callback=funcName ），查询值默认为 callback；</li>
<li>响应方根据查询的参数，构造形如<code>xxx.call(undefined,&#39;数据&#39;)</code>的内容，并响应给浏览器；</li>
<li>浏览器接收到响应，会自动解析请求到<code>script</code>里的数据，执行<code>xxx.call(undefined,&#39;数据&#39;)</code>，就得到想要的数据；</li>
<li>请求完成或请求失败，都会删除生成<code>&lt;script&gt;</code>标签和构建的<code>xxx</code>全局函数。</li>
</ol>
<h3 id="两个约定："><a href="#两个约定：" class="headerlink" title="两个约定："></a>两个约定：</h3><ol>
<li>默认查询参数的值<code>callback=funcName</code>；</li>
<li>funcName 使用随机数，例如 func123456。</li>
</ol>
<h3 id="JSONP-demo"><a href="#JSONP-demo" class="headerlink" title="JSONP demo"></a>JSONP demo</h3><ul>
<li>html 页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-Hans&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSONP-demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你还有<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;money&quot;</span>&gt;</span>$$money$$<span class="tag">&lt;/<span class="name">span</span>&gt;</span>块钱<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>扣1块钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        func = <span class="string">&#x27;func&#x27;</span> + <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10000</span>, <span class="number">10</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>[func] = <span class="function"><span class="keyword">function</span> (<span class="params">respones</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (respones.success) &#123;</span></span><br><span class="line"><span class="javascript">            money.innerText = respones.money</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        script.src = <span class="string">&#x27;http://jack.com:8888/pay?callback=&#x27;</span> + func</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(script)</span></span><br><span class="line"><span class="javascript">        script.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          e.currentTarget.remove()</span></span><br><span class="line"><span class="javascript">          <span class="keyword">delete</span> <span class="built_in">window</span>[func]</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          e.currentTarget.remove()</span></span><br><span class="line"><span class="javascript">          alert(<span class="string">&#x27;failed&#x27;</span>)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">delete</span> <span class="built_in">window</span>[func]</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>server.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var http = require(&#x27;http&#x27;)</span><br><span class="line">var fs = require(&#x27;fs&#x27;)</span><br><span class="line">var url = require(&#x27;url&#x27;)</span><br><span class="line">var port = process.argv[2]</span><br><span class="line"></span><br><span class="line">if(!port)&#123;</span><br><span class="line">  console.log(&#x27;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&#x27;)</span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(request, response)&#123;</span><br><span class="line">  var parsedUrl = url.parse(request.url, true)</span><br><span class="line">  var path = request.url</span><br><span class="line">  var query = &#x27;&#x27;</span><br><span class="line">  if(path.indexOf(&#x27;?&#x27;) &gt;= 0)&#123; query = path.substring(path.indexOf(&#x27;?&#x27;)) &#125;</span><br><span class="line">  var pathNoQuery = parsedUrl.pathname</span><br><span class="line">  var queryObject = parsedUrl.query</span><br><span class="line">  var method = request.method</span><br><span class="line"></span><br><span class="line">  /******** 从这里开始看，上面不要看 ************/</span><br><span class="line"></span><br><span class="line">  if (path === &#x27;/&#x27;) &#123;</span><br><span class="line">    var string = fs.readFileSync(&#x27;./index.html&#x27;,&#x27;utf8&#x27;)</span><br><span class="line">    var account = fs.readFileSync(&#x27;./db&#x27;,&#x27;utf8&#x27;) //100</span><br><span class="line">    string=string.replace(&#x27;$$money$$&#x27;,account)</span><br><span class="line">    response.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html&#x27;,&#x27;charset=utf-8&#x27;)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(pathNoQuery === &#x27;/pay&#x27; &amp;&amp; method.toUpperCase() ===&#x27;GET&#x27; )&#123;</span><br><span class="line">    var account = fs.readFileSync(&#x27;./db&#x27;,&#x27;utf8&#x27;)</span><br><span class="line">    var newaccount = account -1</span><br><span class="line">    fs.writeFileSync(&#x27;./db&#x27;,newaccount)</span><br><span class="line">    response.setHeader(&#x27;Content-Type&#x27;,&#x27;application/javascript&#x27;)</span><br><span class="line">    response.write(`</span><br><span class="line">      $&#123;queryObject.callback&#125;.call(undefined,&#123;</span><br><span class="line">        &#x27;success&#x27;:true,</span><br><span class="line">        &#x27;money&#x27;:`+newaccount+ `</span><br><span class="line">      &#125;)</span><br><span class="line">    `)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.write(&#x27;网页走丢了&#x27;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /******** 代码结束，下面不要看 ************/</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">console.log(&#x27;127.0.0.1:&#x27;+port)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是MVC</title>
    <url>/2018/12/26/%E4%BB%80%E4%B9%88%E6%98%AFMVC/</url>
    <content><![CDATA[<h3 id="什么是-MVC"><a href="#什么是-MVC" class="headerlink" title="什么是 MVC"></a>什么是 MVC</h3><ol>
<li>最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</li>
<li>最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。</li>
<li>中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</li>
</ol>
<span id="more"></span>

<p>Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View<br>用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View</p>
<h3 id="MVC-例子"><a href="#MVC-例子" class="headerlink" title="MVC 例子"></a>MVC 例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> model = Model(&#123;</span><br><span class="line">    <span class="attr">resouceName</span>: <span class="string">&#x27;Message&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> view = View(<span class="string">&#x27;.message&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> controller = &#123;</span><br><span class="line">    <span class="attr">view</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">leaveMessage</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">messageList</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">model</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params">view, model</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.view = view</span><br><span class="line">      <span class="built_in">this</span>.model = model</span><br><span class="line">      <span class="built_in">this</span>.leaveMessage = view.querySelector(<span class="string">&#x27;#leaveMessage&#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.messageList = view.querySelector(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.model.init()</span><br><span class="line">      <span class="built_in">this</span>.messageInit()</span><br><span class="line">      <span class="built_in">this</span>.bindEvents()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">messageInit</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.model.fetch().then(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> array = message.map(<span class="function"><span class="params">value</span> =&gt;</span> value.attributes)</span><br><span class="line"></span><br><span class="line">        array.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> oLi = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">          <span class="keyword">let</span> ospanname = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">          <span class="keyword">let</span> ospanmessage = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">          ospanname.innerText = value.name + <span class="string">&#x27;: &#x27;</span></span><br><span class="line">          ospanmessage.innerText = value.message</span><br><span class="line"></span><br><span class="line">          oLi.appendChild(ospanname)</span><br><span class="line">          oLi.appendChild(ospanmessage)</span><br><span class="line"></span><br><span class="line">          <span class="built_in">this</span>.messageList.appendChild(oLi)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">bindEvents</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.leaveMessage.addEventListener(<span class="string">&#x27;submit&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        <span class="built_in">this</span>.savemessage()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">savemessage</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      leaveMessage = <span class="built_in">this</span>.leaveMessage</span><br><span class="line">      <span class="keyword">let</span> postName = leaveMessage.querySelector(<span class="string">&#x27;input[name=name]&#x27;</span>).value</span><br><span class="line">      <span class="keyword">let</span> postMessages = leaveMessage.querySelector(<span class="string">&#x27;input[name=messages]&#x27;</span>).value</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.model</span><br><span class="line">        .save(&#123;</span><br><span class="line">          <span class="attr">name</span>: postName,</span><br><span class="line">          <span class="attr">message</span>: postMessages</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">          alert(<span class="string">&#x27;提交成功&#x27;</span>)</span><br><span class="line">          <span class="keyword">let</span> ul = view.querySelector(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">          <span class="keyword">let</span> oLi = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">          <span class="keyword">let</span> ospanname = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">          <span class="keyword">let</span> ospanmessage = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line">          ospanname.innerText = object.attributes.name + <span class="string">&#x27;: &#x27;</span></span><br><span class="line">          ospanmessage.innerText = object.attributes.message</span><br><span class="line"></span><br><span class="line">          oLi.appendChild(ospanname)</span><br><span class="line">          oLi.appendChild(ospanmessage)</span><br><span class="line"></span><br><span class="line">          ul.appendChild(oLi)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  controller.init.call(controller, view, model)</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>从零搭建 Vue3 项目</title>
    <url>/2022/12/14/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%20Vue3%20%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>之前项目都是基于 <code>Vue CLI</code> 搭建的，对其脚手架搭建的方式、用了哪些包也只一知半解，现通过从零开始搭建一个 Vue 项目，加深一下印象。</p>
<span id="more"></span>

<h1 id="配置-Webpack-环境"><a href="#配置-Webpack-环境" class="headerlink" title="配置 Webpack 环境"></a>配置 Webpack 环境</h1><p>先抛开 <code>Vue</code> ，先使用 <code>Webpack</code> 搭建一个最初始的项目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建文件夹</span><br><span class="line">mkdir vue3-project &amp;&amp; cd vue3-project</span><br><span class="line">// 初始化项目</span><br><span class="line">yarn init</span><br></pre></td></tr></table></figure>

<p>此时你将会等到只有 <code>package.json</code> 的项目。</p>
<p>然后运行以下命令安装 <code>Webpack</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure>

<p>接下来在根目录新建 <code>src</code> 文件夹，并增加 <code>main.js</code> 文件，并在根目录下创建 <code>index.html</code> 和 <code>webpack.config.js</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir src &amp;&amp; touch ./src/main.js</span><br><span class="line">touch index.html webpack.config.js</span><br></pre></td></tr></table></figure>

<p>并在 <code>webpack.config.js</code> 里添加以下内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 环境模式</span></span><br><span class="line">  <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">&#x27;./src/main.js&#x27;</span>), <span class="comment">// 打包入口</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/[name].js&#x27;</span>, <span class="comment">// 打包完的静态资源文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>), <span class="comment">// 打包出口</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>*注</p>
</blockquote>
<ol>
<li><code>__dirname</code> 返回当前模块文件解析过后所在的文件夹(目录)的绝对路径；</li>
<li><code>path</code> 是 <code>Node.js</code> 提供的用于处理文件路径的小工具，<code>path.resolve</code> 方法将传进来的路径处理成一个绝对路径，<code>path.resolve(__dirname, &quot;dist&quot;)</code> 相当于当前目录下的 <code>dist</code> 文件夹。</li>
</ol>
<p>修改 <code>package.json</code> 的 <code>scripts</code> 属性，使用 <code>webpack.config.js</code> 打包代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack --config ./webpack.config.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行打包指令 yarn dev , 如下所示代表成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ webpack --config ./webpack.config.js</span><br><span class="line">asset js/main.js 1.18 KiB [emitted] (name: main)</span><br><span class="line">./src/main.js 1 bytes [built] [code generated]</span><br><span class="line">webpack 5.75.0 compiled successfully in 71 ms</span><br></pre></td></tr></table></figure>

<h1 id="配置-html-模板"><a href="#配置-html-模板" class="headerlink" title="配置 html 模板"></a>配置 html 模板</h1><p>打包没有 <code>html</code> 文件，<code>html-webpack-plugin</code> 插件可以在打包的时候以 <code>index.html</code> 为模板，输出到 <code>dist</code> 文件夹</p>
<p>运行安装 <code>html-webpack-plugin</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add html-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<blockquote>
<p>*注</p>
</blockquote>
<ol>
<li><code>-D</code> 命令表示只是在开发环境使用，依赖写入到 <code>devDependencies</code></li>
</ol>
<p>安装完成在 <code>webpack.config.js</code> 下引入并使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">// 环境模式</span></span><br><span class="line">  <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">&quot;./src/main.js&quot;</span>), <span class="comment">// 打包入口</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;js/[name].js&quot;</span>, <span class="comment">// 打包完的静态资源文件名</span></span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>), <span class="comment">// 打包出口</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.resolve(__dirname, <span class="string">&quot;./index.html&quot;</span>), <span class="comment">// 我们要使用的 html 模板地址</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>, <span class="comment">// 打包后输出的文件名</span></span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;从零搭建 Vue3 项目&quot;</span>, <span class="comment">// index.html 模板内，通过 &lt;%= htmlWebpackPlugin.options.title %&gt; 拿到的变量</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给 index.html 增加一下内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>给 main.js 增加一下内容</p>
<p>再次运行 <code>yarn dev</code> ，<code>dist</code> 文件夹中多了 <code>index.html</code>，直接访问页面是有文字的，页面的 <code>title</code> 也是设置的 <code>从零搭建 Vue3 项目</code></p>
<h1 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h1><p>每次写完代码都要重新打包才能看到效果，我们需要插件实现一个实时更新最新代码的能力。</p>
<p>话不多说，安装！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<p>在 webpack.config.js 下添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>重新运行一下 <code>yarn dev</code>， 如下所示代表成功，访问 <code>http://localhost:8080/</code>，页面内容和之前访问的一致，并且改动了代码，页面也能正常更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ webpack serve --progress --config ./webpack.config.js</span><br><span class="line">&lt;i&gt; [webpack-dev-server] Project is running at:</span><br><span class="line">&lt;i&gt; [webpack-dev-server] Loopback: http://localhost:8080/</span><br><span class="line">&lt;i&gt; [webpack-dev-server] On Your Network (IPv4): http://192.168.158.146:8080/</span><br><span class="line">&lt;i&gt; [webpack-dev-server] Content not from webpack is served from &#x27;E:\study\vue3-project\public&#x27; directory</span><br><span class="line">asset js/main.js 243 KiB [emitted] (name: main)</span><br><span class="line">asset index.html 305 bytes [emitted]</span><br></pre></td></tr></table></figure>

<h1 id="配置-Vue"><a href="#配置-Vue" class="headerlink" title="配置 Vue"></a>配置 Vue</h1><p>安装 <code>Vue</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add vue</span><br></pre></td></tr></table></figure>

<p>在 <code>./src</code> 目录下新建 <code>App.vue</code>，并增加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;count++&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.app &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>main.js</code> 内容如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>重新运行 <code>yarn dev</code> 命令，报错了~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR in ./src/App.vue 1:0</span><br><span class="line">Module parse failed: Unexpected token (1:0)</span><br><span class="line">You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders</span><br><span class="line">&gt; &lt;template&gt;</span><br><span class="line">|   &lt;div class=&quot;app&quot;&gt;Vue 可以使用了&lt;/div&gt;</span><br><span class="line">| &lt;/template&gt;</span><br><span class="line"> @ ./src/main</span><br><span class="line"> .js 2:0-28 3:22-25</span><br></pre></td></tr></table></figure>

<p>报错内容告诉我们没有 <code>Vue</code> 相关的 <code>loader</code>；</p>
<p>理解了，安装！根据官网提示，要安装 2 个 <code>loader</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add vue-loader vue-template-compiler babel-loader vue-style-loader css-loader -D</span><br></pre></td></tr></table></figure>

<p>然后运行 <code>yarn dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;hot=true&amp;live-reload=true</span><br><span class="line">Module build failed (from ./node_modules/babel-loader/lib/index.js):</span><br><span class="line">Error: Cannot find module &#x27;@babel/core&#x27;</span><br></pre></td></tr></table></figure>

<p>报错了！提示我们安装 <code>@babel/core</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add @babel/core -D</span><br></pre></td></tr></table></figure>

<p>理解了，安装！</p>
<p>然后运行 <code>yarn dev</code>，没有报错了，成功了。</p>
<p>至此，简单的 <code>Vue</code> 项目，就完成了。</p>
<h1 id="使用-vite-搭建"><a href="#使用-vite-搭建" class="headerlink" title="使用 vite 搭建"></a>使用 vite 搭建</h1><p>先把上面项目的 <code>webpack.config.js</code> 配置文件删除，因为我们要使用更快的 <code>vite</code></p>
<p>首先安装 <code>vite</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add vite @vitejs/plugin-vue -D</span><br></pre></td></tr></table></figure>

<p><code>@vitejs/plugin-vue</code> 插件提供了对 vue3 的支持</p>
<p>然后新建 <code>vite.config.js</code> 文件，增加如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [vue()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>package.json</code> 同样修改 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;vite&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;vite build&quot;,</span><br><span class="line">  &quot;preview&quot;: &quot;vite preview&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然后运行 <code>yarn dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VITE v4.0.1  ready in 468 ms</span><br><span class="line"></span><br><span class="line">➜  Local:   http://127.0.0.1:5173/</span><br><span class="line">➜  Network: use --host to expose</span><br><span class="line">➜  press h to show help</span><br></pre></td></tr></table></figure>

<p>提示运行成功了，很疑惑，这么容易就好了吗，太香了把。。。</p>
<p>打开浏览器访问，发现访问页面空白的，似乎页面并没有编译</p>
<p>发现页面 <code>title</code> 是 <code>&lt;%= htmlWebpackPlugin.options.title %&gt;</code>，还是之前 <code>webpack</code> 用的模板，需要修改一下。</p>
<p>直接官网抄过来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/vite.svg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite + Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>都不用重启，页面就好了！</p>
<p>至此，使用 vite 搭建就完成了</p>
<h1 id="自动引入"><a href="#自动引入" class="headerlink" title="自动引入"></a>自动引入</h1><p><code>Vue3</code> 有组合式 <code>API</code> 的语法糖，但是比如需要使用 <code>ref</code> 的时候，都需要在页面引入，使用起来十分不舒服。能不能在使用的时候自动引入呢？</p>
<p>话不多说，安装！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add -D unplugin-auto-import</span><br></pre></td></tr></table></figure>

<p>按照官方要求增加配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> AutoImport <span class="keyword">from</span> <span class="string">&quot;unplugin-auto-import/vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    vue(),</span><br><span class="line">    AutoImport(&#123;</span><br><span class="line">     </span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>删除 ref 引用，页面报错了，ref 并没有引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uncaught ReferenceError: ref is not defined</span><br></pre></td></tr></table></figure>

<p>继续看文档，发现少了配置……</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      include: [</span><br><span class="line">        /\.[tj]sx?$/, // .ts, .tsx, .js, .jsx</span><br><span class="line">        /\.vue$/,</span><br><span class="line">        /\.vue\?vue/, // .vue</span><br><span class="line">        /\.md$/, // .md</span><br><span class="line">      ],</span><br><span class="line">      // global imports to register</span><br><span class="line">      imports: [</span><br><span class="line">        &quot;vue&quot;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>*注</p>
</blockquote>
<ol>
<li><code>include</code> 表示符合这些结尾的文件，都可以自动引用；</li>
<li><code>imports</code> 表示这些的包提供的方法，能全局使用。</li>
</ol>
<p>真香！现在组件也不想手动引入了，可以吗？</p>
<p>话不多说，安装！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add -D unplugin-vue-components/vite</span><br></pre></td></tr></table></figure>

<p>在 <code>vite.config.ts</code> 添加配置，想都不用想，肯定也要加配置的，文档接着往下翻，然后复制过来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Components(&#123; </span><br><span class="line">   dirs: [&#x27;src/components&#x27;],</span><br><span class="line"> &#125;),</span><br></pre></td></tr></table></figure>

<blockquote>
<p>*注</p>
</blockquote>
<ol>
<li><code>dirs</code> 表示这个目录下的文件可以被自动引入</li>
</ol>
<p>我们 <code>src</code> 下新建组件，然后在 <code>App</code> 组件里直接使用，页面直接更新了！</p>
<p><a href="https://github.com/quietdw/vue3-test1/tree/vite">代码地址</a></p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://webpack.js.org/guides/getting-started/#basic-setup">Getting Started</a></li>
<li><a href="https://juejin.cn/post/6921161482663100423">Vue 3 和 Webpack 5 来了，手动搭建的知识该更新了</a></li>
<li><a href="https://github.com/webpack/webpack-dev-server">webpack-dev-server</a></li>
<li><a href="https://vue-loader.vuejs.org/zh/guide/">Vue Loader</a></li>
<li><a href="https://cn.vitejs.dev/guide/#index-html-and-project-root">index.html 与项目根目录</a></li>
<li><a href="https://stackblitz.com/edit/vitejs-vite-xm5kcu?file=package.json&terminal=dev">vite-vue-starter</a></li>
<li><a href="https://github.com/antfu/unplugin-auto-import">unplugin-auto-import</a></li>
<li><a href="https://github.com/antfu/unplugin-vue-components">unplugin-vue-components</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue3</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Vue directives 封装 clipboard</title>
    <url>/2022/01/22/%E4%BD%BF%E7%94%A8%20Vue%20directives%20%E5%B0%81%E8%A3%85%20clipboard.md/</url>
    <content><![CDATA[<p>最近在使用 clipboard 实现复制到剪切板的功能，发现在 Vue 中使用不是那么丝滑，想着怎么封装一下。</p>
<span id="more"></span>

<p>查看 clipboard 的文档，发现该插件是通过操作 DOM，来实现复制剪切板的功能。而 Vue 也贴心的提供了 directives 方便我们对普通 DOM 元素进行底层操作。</p>
<h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><iframe height="300" style="width: 100%;" scrolling="no" title="directives 初步使用" src="https://codepen.io/quietdw/embed/zYEQMVr?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/quietdw/pen/zYEQMVr">
  directives 初步使用</a> by jiang (<a href="https://codepen.io/quietdw">@quietdw</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<p>当我们点击复制按钮的的时候，控制台打印 <code>复制成功: Welcome to Vue!</code>。但是当我们更改 input 里面的内容时，点击复制按钮，控制台还是打印 <code>复制成功: Welcome to Vue!</code>，并没有按照我们希望的方式更新剪切板的内容。</p>
<h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><p>我们希望在 input 的值更新时，点击复制按钮，剪切板的值也能更新。directives 有 update 钩子函数，可以更新值。我们把 new 出来的 <code>cbd</code> 保存到 <code>el</code> 上，这样我们在 update 钩子函数中也能通过 <code>cbd</code> 更新剪切板的内容。不使用了的时候，需要在 unbind 钩子中摧毁实例。</p>
<iframe height="300" style="width: 100%;" scrolling="no" title="directives 进阶使用" src="https://codepen.io/quietdw/embed/MWEdZEy?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/quietdw/pen/MWEdZEy">
  directives 进阶使用</a> by jiang (<a href="https://codepen.io/quietdw">@quietdw</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<h3 id="再加一点点"><a href="#再加一点点" class="headerlink" title="再加一点点"></a>再加一点点</h3><p>有时复制失败，或者复制成功后想要做一些操作，clipboard 有这两种回调函数，我们需要在 directives 中保留一下。通过给指令传参数，我们可以绑定多个值。</p>
<iframe height="300" style="width: 100%;" scrolling="no" title="directives 进阶使用" src="https://codepen.io/quietdw/embed/LYzoMXm?default-tab=js%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/quietdw/pen/LYzoMXm">
  directives 进阶使用</a> by jiang (<a href="https://codepen.io/quietdw">@quietdw</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://clipboardjs.com/#example-target">clipboard.js</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/custom-directive.html">自定义指令</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>directives</tag>
        <tag>clipboard</tag>
      </tags>
  </entry>
  <entry>
    <title>使用new后到底发生了什么？</title>
    <url>/2018/12/27/%E4%BD%BF%E7%94%A8new%E5%90%8E%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>当代码 new Foo(…) 执行时，会发生以下事情：</p>
<ol>
<li>首先新建一个空对象，空对象的 <code>__proto__</code> ，指向该构造函数的 <code>prototype</code>;</li>
<li>构造函数的内部的 <code>this</code> 指向上面的空对象</li>
<li>如果该函数没有返回对象，则返回 <code>this</code></li>
</ol>
<span id="more"></span>

<p>用代码表示，就是以下过程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// var temp=&#123;&#125;</span></span><br><span class="line"><span class="comment">// this = temp</span></span><br><span class="line"><span class="comment">// this.__proto__ = Foo.prototype</span></span><br><span class="line"><span class="built_in">this</span>.xxx=xxx</span><br><span class="line">...</span><br><span class="line"><span class="comment">//return this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟一下 new</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, arg)</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj <span class="comment">// 如果该函数没有返回对象，则返回obj</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new 的作用，就是省那么几行代码。（也就是所谓的语法糖）</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/23987456">JS 的 new 到底是干什么的？</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流</title>
    <url>/2019/03/17/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>有些事件，如 <code>onresize</code> 事件，高频更改可能导致浏览器崩溃。为了绕开这个问题，可以使用定时器对该函数进行节流。</p>
<span id="more"></span>

<h1 id="屯着一起送"><a href="#屯着一起送" class="headerlink" title="屯着一起送"></a>屯着一起送</h1><p>举个例子，小明去送外卖，收到订单后，不会马上去送，而是等个 1 分钟，5 分钟内如果又有订单，就再等着，直到 5 分钟内没有新的订单。</p>
<p>用代码表示就是这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>送外卖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">      callback()</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delivery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我去送外卖了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx.onclick = debounce(delivery, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h1 id="技能-CD"><a href="#技能-CD" class="headerlink" title="技能 CD"></a>技能 CD</h1><p>依旧举个例子，lol 中某英雄的技能 CD 是 10s，ta 至少每隔 10 秒才能放同一个技能。</p>
<p>用代码表示就是这样的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>施放 Q 技能<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fired = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fired) &#123;</span><br><span class="line">      fired = <span class="literal">true</span></span><br><span class="line">      callback()</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fired = <span class="literal">false</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fire</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;施放了 Q 技能&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx.onclick = throttle(fire, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>两种方式都使用了闭包，但只是简单的实现，目前 lodash 和 underscore 这两个 js 库都对以上方法进行了封装，功能也更完善。</p>
]]></content>
      <tags>
        <tag>函数节流</tag>
      </tags>
  </entry>
  <entry>
    <title>初识jQuery</title>
    <url>/2018/12/11/%E5%88%9D%E8%AF%86JQuery/</url>
    <content><![CDATA[<p>jQuery 的思路：</p>
<ol>
<li>接收一个选择器</li>
<li>将选择的元素封装成一个伪数组</li>
<li>对伪数组封装了几个 API</li>
<li>返回这个伪数组</li>
</ol>
<span id="more"></span>

<p>版本一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;内容&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(node)<span class="comment">//nodes是个伪数组，用户以为操作的是node，其实是伪数组nodes</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> &#123;<span class="comment">//返回addClass、setText两个方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">addClass</span>: <span class="function"><span class="keyword">function</span>(<span class="params">cls</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,key</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       nodes[key].classList.add(cls)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;)<span class="comment">//nodes和函数形成了一个闭包</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">setText</span>: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,key</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       nodes[key].textContent = text</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">window</span>.$ = jQuery <span class="comment">//全局可以使用$符号</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> $div = $(<span class="string">&#x27;div&#x27;</span>)<span class="comment">//$div就有addClass、setText两个方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">$div.addClass(<span class="string">&#x27;red&#x27;</span>) <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">$div.setText(<span class="string">&#x27;hi&#x27;</span>) <span class="comment">// 可将所有 div 的 textContent 变为 hi</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>版本二</p>
<p>将方法绑定在 nodes 上，返回一个 nodes</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(node)</span><br><span class="line"></span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span> (<span class="params">cls</span>) </span>&#123;</span><br><span class="line">    nodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">      nodes[key].classList.add(cls)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodes.setText = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    nodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">      nodes[key].textContent = text</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/22486908">JS 中的闭包是什么？</a></p>
]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2018/11/28/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h1><p>在 javascript 中，全局函数<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Object</code>等，都有<code>toSting()</code>、<code>valueOf()</code>等方法，倘若每个函数都独自定义这些相同的属性和方法，势必对内存造成极大的浪费。因此这些相同的属性和方法，都被集合到一起，对象可通过<code>__proto__</code>属性访问这些共用属性<code>prototype</code>，比如：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true obj共用Object的属性</span></span><br><span class="line">n.__proto__ === <span class="built_in">Number</span>.prototype <span class="comment">//true，n共用Number的属性</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">//true，Number.prototype 本身也是个对象，共用Object的属性</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">s.__proto__ === <span class="built_in">String</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>有几点需要注意：</p>
<p><code>var 对象 = new 函数()</code></p>
<p><code>对象.__proto__ === 对象的构造函数.prototype</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true,因为 Number 是 Function 的实例</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true,因为 Object 是 Function 的实例</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototye <span class="comment">// true,因为 Function 是 Function 的实例！</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.__proto__ <span class="comment">// true,因为 Function.__proto__ === Function.prototye</span></span><br></pre></td></tr></table></figure>

<h1 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h1><p>每个实例对象（object ）都有一个私有属性（称之为<strong>proto</strong>）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象(<strong>proto</strong>) ，层层向上直到一个对象的原型对象为 null。这种链式结构，称之为原型链</p>
<p><img src="https://jiangnana.fun/test/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg" alt="原型链"></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型链</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序代码分析</title>
    <url>/2018/11/01/%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//交换i，j的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = array[i]</span><br><span class="line">    array[i] = array[j]</span><br><span class="line">    array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//比较当前节点与子节点的大小，形成一个最大堆</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iMax, iLeft, iRight</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      iMax = index <span class="comment">//默认父元素最大</span></span><br><span class="line">      iLeft = <span class="number">2</span> * index + <span class="number">1</span> <span class="comment">//根据父节点的索引，计算出左子节点的索引</span></span><br><span class="line">      iRight = <span class="number">2</span> * (index + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123;</span><br><span class="line">        <span class="comment">//iLeft &lt; heapSize说明还未到叶节点，然后才比较值的大小</span></span><br><span class="line">        iMax = iLeft</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</span><br><span class="line">        iMax = iRight</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果最大值的索引发生了改变，则交换二者的位置，使符合最大堆定义，因为子节点的值发生了改变，子节点下面的值需要重新排序。</span></span><br><span class="line">      <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">        swap(array, iMax, index)</span><br><span class="line">        index = iMax</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将数组构造成最大堆</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">      iParent = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>) - <span class="number">1</span> <span class="comment">//根据传来数组，计算最后一个元素其父节点的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">//从下往上，构造最大堆；</span></span><br><span class="line">      maxHeapify(array, i, array.length)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    buildMaxHeap(array)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      swap(array, <span class="number">0</span>, i) <span class="comment">//将第一项和最后一项交换位置</span></span><br><span class="line">      maxHeapify(array, <span class="number">0</span>, i) <span class="comment">//因为根节点元素发生了改变，重新构造最大堆,0-i,后面是排好序的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回排序好的数组</span></span><br><span class="line">  <span class="keyword">return</span> sort(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">常见排序算法 - 堆排序 (Heap Sort)</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>多个迭代器</title>
    <url>/2021/02/19/%E5%A4%9A%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>多个迭代器彼此交替运行的时候，不同的顺序，<code>yield</code> 的位置，都可能有不同的输出。</p>
<span id="more"></span>

<p>先知道生成器里的两个概念，方便我们理解计算下面几个例子：</p>
<pre><code>1. yield 表达式本身没有返回值，或者说总是返回 undefined；
2. next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。
</code></pre>
<p>《你不知道的 JavaScript（中卷）》有个例子：</p>
<iframe height="415" style="width: 100%;" scrolling="no" title="多个生成器1" src="https://codepen.io/quietdw/embed/wvoeEgp?height=412&theme-id=light&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/quietdw/pen/wvoeEgp'>多个生成器1</a> by jiang
  (<a href='https://codepen.io/quietdw'>@quietdw</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>自己算，结果出来了，很快啊。</p>
<p>然后第二个例子：</p>
<iframe height="415" style="width: 100%;" scrolling="no" title="多个生成器2" src="https://codepen.io/quietdw/embed/yLVXxrd?height=416&theme-id=light&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/quietdw/pen/yLVXxrd'>多个生成器2</a> by jiang
  (<a href='https://codepen.io/quietdw'>@quietdw</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>最后一次输出怎么是 <code>12, 18</code> 呢，不是 <code>12, 24</code> 吗？</p>
<p>发现有一行代码 <code>b = a * (yield 2)</code></p>
<blockquote>
<p>大胆猜测：会不会是因为这里的 <code>a</code> 此时还是之前运行到这一步已近确定结果的 <code>a</code> 呢？</p>
</blockquote>
<p>我们把代码再改一下，验证一下：</p>
<iframe height="415" style="width: 100%;" scrolling="no" title="多个生成器3" src="https://codepen.io/quietdw/embed/XWNgxrX?height=411&theme-id=light&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/quietdw/pen/XWNgxrX'>多个生成器3</a> by jiang
  (<a href='https://codepen.io/quietdw'>@quietdw</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>发现果然如此！</p>
]]></content>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>如何发布npm包</title>
    <url>/2019/03/27/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83npm%E5%8C%85/</url>
    <content><![CDATA[<p>最近在造轮子的过程中，需要将本地的代码发布到 npm 上，方便他人使用。写一篇博客方便以后查阅。</p>
<span id="more"></span>

<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><ol>
<li><p>在根目录建立 index.js 的文件，需与 package.json 中 main 的值一致。</p>
</li>
<li><p>将写好的组件导入到 index.js 中，形如：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&quot;dist&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>如报错提示不支持 import 的语法， 可在使用 parcel<br><code>mpx parcel build index.js --no-minify --no-cache</code> 将文件转移成兼容版本。</p>
</li>
<li><p>上传</p>
</li>
</ol>
<ul>
<li>第一次发布前需要使用 <code>npm adduser</code> 添加在 npm 上注册的用户名；</li>
<li><code>npm publish</code> 发布。</li>
</ul>
<h1 id="测试包"><a href="#测试包" class="headerlink" title="测试包"></a>测试包</h1><p>在包发布以后，每次包升级，需要测试。如果每次上传，都本地安装测试，会比较麻烦，而且不利于用户使用。</p>
<ol>
<li><p>在项目处使用 <code>npm link</code>；</p>
</li>
<li><p>测试目录使用 <code>npm link 包的名字</code>。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>如何调试手机页面</title>
    <url>/2019/02/21/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%89%8B%E6%9C%BA%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>如何在手机端调试的时候输出报错信息呢？</p>
<p>我这儿先写两种比较方便的方法。</p>
<span id="more"></span>

<h1 id="处在同一个局域网"><a href="#处在同一个局域网" class="headerlink" title="处在同一个局域网"></a>处在同一个局域网</h1><p>手机连接和电脑同一个局域网的网络，如同一个路由器</p>
<h1 id="访问-PC-提供的-HTTP-服务"><a href="#访问-PC-提供的-HTTP-服务" class="headerlink" title="访问 PC 提供的 HTTP 服务"></a>访问 PC 提供的 HTTP 服务</h1><p>如 http-server</p>
<h1 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h1><p>首先手机端是没 F12 可以按的，而且手机端也没控制台这个东西的。。</p>
<p>有两种简单方法可以让程序员获取调试信息。</p>
<h2 id="使用alert"><a href="#使用alert" class="headerlink" title="使用alert()"></a>使用<code>alert()</code></h2><pre><code>手机端没有控制台，因而查看不到输出的信息。可用`alert()`直接弹出信息。
</code></pre>
<h2 id="重写console"><a href="#重写console" class="headerlink" title="重写console"></a>重写<code>console</code></h2><pre><code>重写`console`函数，简单的例子：
</code></pre>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;consoleData&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.console = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">log</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      p.innerText = e</span></span><br><span class="line"><span class="javascript">      consoleData.appendChild(p)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, file, row</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(message)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(file)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(row)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>上面的例子通过重写console函数，将调试信息加载到页面中，同时也劫持了`window.onerror`函数，将页面的报错信息通过重写后的console.log()渲染到页面中，这样调试者也能看到调试信息

当然，肯定早有人知道这种方法，并且写的还贼好的。比如腾讯的[vconsole](https://github.com/Tencent/vConsole)，使用方法也非常简单，只要在页面中添加如下代码：
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;path/to/vconsole.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole();</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="注意事项！"><a href="#注意事项！" class="headerlink" title="注意事项！"></a>注意事项！</h1><pre><code>记得调试后把调试代码都清理掉！！
</code></pre>
]]></content>
      <tags>
        <tag>console</tag>
        <tag>手机端</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>实现极简版reactive</title>
    <url>/2020/06/22/%E5%AE%9E%E7%8E%B0%E6%9E%81%E7%AE%80%E7%89%88reactive/</url>
    <content><![CDATA[<p>Vue3.0 出来有一段是时间了，趁着有点空，跟着大佬一起学习一下新的响应式系统。</p>
<span id="more"></span>

<p>为了收集数据依赖、以及在数据变化时更新视图，Vue2 通过 defineProperty 劫持 set 和 get 属性访问描述符。</p>
<p>defineProperty 存在一些问题，最常见的问题就是无法监听对象以及数组动态添加的属性，即使 Vue2 重写了数组原型相关方法，但仍旧无法监听到<code>arr[1]=xxx</code>这种形式。</p>
<p>Vue3 使用了 ES6 新增的 Proxy 接口来替代 defineProperty。</p>
<p>Proxy 对象用于定义基本操作的自定义行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p = new Proxy(target, handler)</span><br></pre></td></tr></table></figure>

<p>其中 handler 对象是一个容纳一批特定属性的占位符对象，它包含有 Proxy 的各个捕获器 trap，如 set、get`等</p>
<p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<ul>
<li><p>set 方法应该返回一个布尔值，在严格模式下，如果 set 方法返回 falsish(包括 undefined、false 等)，会抛出异常，这些细节比较麻烦，可以通过 Reflect 来处理</p>
</li>
<li><p>如果代理对象是数组，当调用 push、pop 等方法时，不仅会改变数组元素，也会改变 length 等属性，此时如果代理了 set，则会被触发多次。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [100,200,300]</span><br><span class="line">let p = new Proxy(arr, &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    return target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value, receiver) &#123;</span><br><span class="line">    console.log(&#x27;set value&#x27;, key)</span><br><span class="line">    target[key] = value</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.push(400)</span><br><span class="line">// set value 3 第一次data[3] = 400</span><br><span class="line">// set value length 第二次 data.length = 4</span><br></pre></td></tr></table></figure>

<p>60 行代码实现简易的 reactive</p>
<p><code>index.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let activeEffect</span><br><span class="line">let targetMap = new Map()</span><br><span class="line"></span><br><span class="line">function reactive(obj)&#123;</span><br><span class="line">    return new Proxy(obj, &#123;</span><br><span class="line">        get(target, key)&#123;</span><br><span class="line">            track(target, key)</span><br><span class="line">            return target[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, key, value)&#123;</span><br><span class="line">            target[key] = value</span><br><span class="line">            trigger(target, key)</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function track(target, key)&#123;</span><br><span class="line">    let depMap = targetMap.get(target) // 获取 key 是 target 对象的值，感觉是对象的地址</span><br><span class="line">    if(!depMap) &#123; // 如果没有，就新增加一个，target 相关联的值初始化程一个Map</span><br><span class="line">        targetMap.set(target, (depMap = new Map()))</span><br><span class="line">    &#125;</span><br><span class="line">    let dep = depMap.get(key) // 获取 key 的相关联的数据</span><br><span class="line">    if(!dep) &#123; // 没有就初始化成一个 Set</span><br><span class="line">        depMap.set(key, ( dep = new Set()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     // 给 key 添加 activeEffect，值变动了会执行trigger函数，执行该函数</span><br><span class="line">    if(!dep.has(activeEffect))&#123;</span><br><span class="line">        dep.add(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function watchEffect(cb)&#123;</span><br><span class="line">    activeEffect = cb</span><br><span class="line">    cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function trigger(target, key)&#123;</span><br><span class="line"></span><br><span class="line">    let depMap = targetMap.get(target)</span><br><span class="line">    if(!depMap) return</span><br><span class="line">    let effects =  depMap.get(key)</span><br><span class="line">    if(!effects) return</span><br><span class="line"></span><br><span class="line">    effects.forEach((effect)=&gt;&#123;</span><br><span class="line">        effect()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>index.html</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      let state = reactive(&#123;</span><br><span class="line">        x: 100,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      function render() &#123;</span><br><span class="line">        let msg = `render template with state.x = $&#123;state.x&#125;`</span><br><span class="line">        console.log(msg)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      watchEffect(render)</span><br><span class="line"></span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        state.x = 200</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy - MDN</a></li>
<li><a href="https://juejin.im/post/5ec68bc8518825434980044e#heading-10">Vue3 源码分析——数据侦测</a></li>
<li><a href="https://github.com/vuejs/vue-next">vue-next</a></li>
</ul>
]]></content>
      <tags>
        <tag>Vue3</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>对类的初步认识</title>
    <url>/2018/12/26/%E5%AF%B9%E7%B1%BB%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>之前的 <a href="https://jiangnana.fun/2018/12/26/%E4%BB%80%E4%B9%88%E6%98%AFMVC">MVC</a> 案例，初步认识了 MVC 是什么。但是当项目中，有多个模块，每个模块都初始化 MVC，就显得非常冗余。这时需要将相同的代码提出来，声明一个函数，以后每次要声明 MVC 时，就调用这个函数。</p>
<span id="more"></span>

<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.View = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelectorAll(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.Model = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resouceName = options.resouceName</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> APP_ID = <span class="string">&#x27;KMOXV4q9U0oDj41GjcqDuFe0-gzGzoHsz&#x27;</span></span><br><span class="line">      <span class="keyword">var</span> APP_KEY = <span class="string">&#x27;vt42FiDltVxEsHYopyyLvLDj&#x27;</span></span><br><span class="line">      AV.init(&#123;</span><br><span class="line">        <span class="attr">appId</span>: APP_ID,</span><br><span class="line">        <span class="attr">appKey</span>: APP_KEY</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fetch</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(resouceName)</span><br><span class="line">      <span class="keyword">return</span> query.find()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">save</span>: <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> X = AV.Object.extend(resouceName)</span><br><span class="line">      <span class="keyword">var</span> x = <span class="keyword">new</span> X()</span><br><span class="line">      <span class="keyword">return</span> x.save(object)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  controller = Controller(&#123;</span></span><br><span class="line"><span class="comment">//     ...</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// controller.init(view,model)</span></span><br><span class="line"><span class="built_in">window</span>.Controller = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> init = options.init</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">view</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">model</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params">view, model</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.view = view</span><br><span class="line">      <span class="built_in">this</span>.model = model</span><br><span class="line">      <span class="built_in">this</span>.model.init()</span><br><span class="line">      init.call(<span class="built_in">this</span>, view, model) <span class="comment">//options的init，this是object。因遍历了options，所以object里也有option自带的属性</span></span><br><span class="line">      <span class="built_in">this</span>.bindEvents()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">bindEvents</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">&#x27;init&#x27;</span>) &#123;</span><br><span class="line">      object[key] = options[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// 将options上个性化的属性添加到object，并返回object</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>面向对象</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>巧用 Git 分支</title>
    <url>/2020/08/19/%E5%B7%A7%E7%94%A8%20Git%20%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>写代码不出 bug 这个事情呢，不能强求的，有时候在新分支（b0）开发新版本开发到一半，线上版本（master）忽然冒出一个 bug 或者功能急需变更，这时就要切换到 master，紧急修复，然后再切回 b0 继续开发；</p>
<span id="more"></span>

<p>具体要怎么操作呢？</p>
<p>我们要建立分支 b0，在上面开发新版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git checkout -b b0</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面是下面两句的简写</span></span><br><span class="line"><span class="comment">//git branch b0 新建分支b0</span></span><br><span class="line"><span class="comment">//git checkout b0 切换到分支b0</span></span><br></pre></td></tr></table></figure>

<p>然后线上版本 bug 了，切回线上版本，新建分支 b1 紧急修复</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b b1</span><br></pre></td></tr></table></figure>

<p>修复成功后合并 b1，并删除 b1 分支</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge b1</span><br><span class="line">git branch -d b1</span><br></pre></td></tr></table></figure>

<p>然后再愉快切回一开始开发的分支 b0 上，此时 b0 分支上是没有 b1 修改的东西，因为创建 b0 分支在 b1 分支前面，可以使用 git merge master 命令将 master 分支合并入 b0 分支，或者你也可以等到 b0 分支完成其使命，再将其合并回 master 分支。</p>
<p>merge 过程中，可能会存在冲突导致合并失败，就要老老实实一个一个手动选择合并了。</p>
<p>至此，一个修复流程就走完毕了。</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6"> Git 分支 - 分支的新建与合并</a></li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>常见网站攻击</title>
    <url>/2019/03/13/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%AB%99%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>网站安全是每个开发者都必须要了解的事情。本人从前端开发的角度，简单说一下几种常见的攻击手段以及如何防止这类攻击。</p>
<span id="more"></span>

<h1 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h1><p>XSS 全称是 Cross-site scripting ，是一种漏洞，攻击者可以利用这种漏洞在网站上注入恶意脚本代码。这些恶意内容通常包括 JavaScript，但有时包括 HTML，Flash 或浏览器可以执行的任何其他代码。当被攻击者打开网站时就会自动运行这些恶意代码，这些脚本就会获取用户在该网站下保留的任意敏感信息。</p>
<p>举个例子：</p>
<p>某网站有个评论系统，攻击者评论时输入类如：</p>
<p><code>&lt;script&gt;alert(&#39;我是恶意代码&#39;)&lt;/script&gt;</code></p>
<p>或者</p>
<p><code>&lt;img src=&quot;http://url.to.file.which/not.exist&quot; onerror=alert(document.cookie);&gt;</code></p>
<p>那么当其他用户登陆评论时，就会自动执行这些代码。</p>
<h2 id="如何防止-XSS-攻击"><a href="#如何防止-XSS-攻击" class="headerlink" title="如何防止 XSS 攻击"></a>如何防止 XSS 攻击</h2><p>坚持一条准则：永远不要相信用户输入的数据。</p>
<p>在后端，可以将可疑的符号转码，比如 <code>&amp;</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&quot;</code>，<code>&#39;</code> ，在响应头中设置 cookie HttpOnly。</p>
<p>在前端，不使用 html(),innerHTml(),eval()等 API，使用安全的 innerText().</p>
<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><p>CSRF 的全称是 Cross-Site Request Forgery，是一种欺骗受害者提交恶意请求的攻击。它拥有受害用户的身份信息，然后跨站伪造用户的请求。</p>
<p>打个比方，比如 a 向 b 转 100 块钱是类似这样的请求：</p>
<p><code>http://alipay.com/send?acct=b&amp;amount=100</code></p>
<p>b 在 a 登陆网银的时候，诱导 a 打开一个页面，通常是一封包含 html 的邮件或者植入在页面中的链接类似：</p>
<p><code>&lt;a href=&quot;http://alipay.com/send?acct=b&amp;amount=100&quot;&gt;View my Pictures!&lt;/a&gt;</code></p>
<p>或</p>
<p><code>&lt;img src=&quot;http://alipay.com/send?acct=b&amp;amount=100&quot; width=&quot;0&quot; height=&quot;0&quot; border=&quot;0&quot;&gt;</code></p>
<p>当用户打开这个邮件时，a 不会看到任何东西，但是浏览器依然会发送这个请求给 alipay.com。</p>
<h2 id="如何防止-CSRF-攻击"><a href="#如何防止-CSRF-攻击" class="headerlink" title="如何防止 CSRF 攻击"></a>如何防止 CSRF 攻击</h2><p>可以采用 <code>anti-csrf-token</code> 方案</p>
<p>具体方案如下：</p>
<ol>
<li>服务端在接收到用户请求时，会生成一个随机数 <code>_csrf_token</code>，并在渲染页面的时候埋入页面中，一般是 form 表单中；</li>
<li>服务端设置 setCookie，把 <code>_csrf_token</code> 作为 cookie 或者 session 种入到用户浏览器；</li>
<li>用户在发送请求时都会带上 <code>_csrf_token</code> 的参数；</li>
<li>后台在处理用户请求时，会对照 cookie 和 form 表单中的 <code>_csrf_token</code> 值，如果一样则表示请求时合法的。</li>
</ol>
<p>有几点要注意：</p>
<ol>
<li>token 放在 session 中，倘若用户打开了很多页面，新的页面是用新的 token ，而之前的页面的 token 还未更新，旧的页面用户就无法提交；</li>
<li>尽量少用 get，倘若攻击者在网站上传了一张图片，用户加载图片的时候会向攻击者的服务器发送请求，并且请求带有的 referer 表示当前图片所造页面的 url ，因 get 的参数在 url 中，攻击者就能获取 url 中的 token 参数。</li>
</ol>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">Cross-Site Request Forgery (CSRF)</a></li>
<li><a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">Cross-site Scripting (XSS)</a></li>
</ul>
]]></content>
      <tags>
        <tag>XSS</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>弄懂 JavaScript 执行机制</title>
    <url>/2019/03/11/%E5%BC%84%E6%87%82%20JavaScript%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>以前以为 JavaScript 是按照语句执行顺序执行的，直到现在被打脸了</p>
<span id="more"></span>

<p>举个的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>按照以前的思路，运行结果应该是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">script end</span><br></pre></td></tr></table></figure>

<p>去 Chrome 浏览器里验证了一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>

<p>而且令人抓狂的是，不同浏览器输出的结果也不尽相同，下文的结果均以 Chrome 的为例。</p>
<p>要了解为什么会输出这样的结果，我们需要了解 JavaScript 运行机制。</p>
<p>首先我们要了解 event loop 是怎么处理 macrotasks 和 microtasks 。</p>
<p>JavaScript 是单线程的，这个 event loop 是持续的运行，而且有许多 macrotasks 在队列等待被执行，但是是浏览器选择怎么执行的。一次鼠标点击事件的回调需要一次 macrotasks ，同样包括解析 HTML， 也包括 setTimeout。</p>
<p>setTimeout 等待当前 macrotasks 结束，才能执行。这也解释 为什么 setTimeout 在 script end 后面，因为输出 script end 也是第一个 macrotasks 部分之一。</p>
<p><strong>macrotasks 执行完后不会马上执行下一个 macrotasks，而是会处理当前 macrotasks 产生的 microtasks 队列，然后才会执行下一个 macrotasks。microtasks 一般是异步的操作，比如回调什么的。在处理 microtasks 时产生的 microtasks 也会被加到当前 macrotasks 队列中，最终也会被执行。</strong></p>
<p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<p><strong>macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval</strong></p>
<p><strong>micro-task(微任务)：Promise，process.nextTick</strong></p>
<p>这样我们就能解释上面代码为什么会出现那样的结果了</p>
<p>首先解析 JavaScript 是第一个 macrotasks。</p>
<p>从上往下执行，先打印 <code>script start</code></p>
<p>遇到 setTimeout，不执行，扔到下一个 macrotasks；</p>
<p>遇到 promise ，是异步的，不执行，扔到当前 macrotasks 的 microtasks 中；</p>
<p>到最后一行，打印 <code>script end</code>；</p>
<p>然后再去 microtasks 看看有没有事情要做；</p>
<p>然后 打印 <code>promise1</code> 和 <code>promise1</code>，promise 返回 undefined；</p>
<p>然后再到下一个 macrotasks，发现是 setTimeout，打印 <code>setTimeout</code>。</p>
<p>关于 setTimeout 要补充的是：即便主线程为空，0 毫秒实际上也是达不到的。根据 HTML 的标准，最低是 4 毫秒。有兴趣的同学可以自行了解。</p>
<p>觉得自己弄懂了吗？</p>
<p>做个小例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> func2()</span><br><span class="line">  <span class="comment">//以下所有内容都被放置微任务中</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func1()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 Chrome 输出结果是：1,b,7,a,6,8,2,4,3,5,9,11,10,12</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://juejin.im/post/59e85eebf265da430d571f89#heading-4">这一次，彻底弄懂 JavaScript 执行机制</a></li>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>macroTask</tag>
        <tag>microTask</tag>
        <tag>宏任务</tag>
        <tag>微任务</tag>
      </tags>
  </entry>
  <entry>
    <title>弄懂 Promise 的 async 和 await</title>
    <url>/2019/04/24/%E5%BC%84%E6%87%82%20Promise%20%E7%9A%84%20async%20%E5%92%8C%20await/</url>
    <content><![CDATA[<p>在 MDN 中，关于 async function 是这么解释的：async function 声明用于定义一个返回 <code>AsyncFunction</code> 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 <code>Promise</code> 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数.</p>
<span id="more"></span>

<p>初读的时候一知半解，但大概了解 async 和 Promise 有关，是一个异步函数，但是像同步函数。</p>
<p>通过例子更直观的了解一下，日常是这么使用 Promise 的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 两个钩子</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="number">5</span></span><br><span class="line">      resolve(a)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().then(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 注：这个函数和 resolve 不是同一个函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以 通过 async await 改写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="number">5</span></span><br><span class="line">      resolve(a)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 内部函数有异步操作，所以要用 async 标识</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="keyword">await</span> fn()</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>await 一定要和 async 一起使用，单独使用会报错。</p>
<p>除了 resolve ，还要处理 reject ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="number">5</span></span><br><span class="line">      <span class="keyword">if</span> (a &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        resolve(a)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(a) <span class="comment">// 会执行这一步</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="keyword">await</span> fn()</span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`error:<span class="subst">$&#123;error&#125;</span>`</span>) <span class="comment">// error:5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() <span class="comment">// error:5</span></span><br></pre></td></tr></table></figure>

<p>上面两个 await 的例子，可能没有 then 简洁，但是逻辑很“同步”，当有需要处理问题时，不会太容易出错。</p>
<p>await 后面只能跟一个 Promise，当需要处理多个 PRomise 时，请使用 Promise.all()</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async function
</a></li>
</ul>
]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>async</tag>
        <tag>await</tag>
      </tags>
  </entry>
  <entry>
    <title>手写 Promise</title>
    <url>/2020/07/27/%E6%89%8B%E5%86%99%20Promise/</url>
    <content><![CDATA[<p>现在前端面试越来越高深莫测了，居然还要手写 Promise。不会啊，怎么办！赶紧自己借鉴一下，手撸一个。</p>
<span id="more"></span>

<p>只实现基础功能和</p>
<ul>
<li>Promise 肯定是一个类，同时还定义了 resolve 和 reject 方法 ;</li>
<li>Promise 有三个状态 <code>pending</code>、<code>fulfilled</code>、<code>rejected</code>;</li>
<li>Promise 的 prototype 上有 then 方法，then 方法会返回一个新的 Promise，可实现链式调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">  let self = this</span><br><span class="line"></span><br><span class="line">  // 初始的状态</span><br><span class="line">  self.status = &#x27;pending&#x27;</span><br><span class="line">  // 成功后的值</span><br><span class="line">  self.value = undefined</span><br><span class="line">  // 失败的原因</span><br><span class="line">  self.reason = undefined</span><br><span class="line"></span><br><span class="line">  // 成功后的回调</span><br><span class="line">  self.onResolved = []</span><br><span class="line">  // 失败后的回调</span><br><span class="line">  self.onRejected = []</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    if (self.status === &#x27;pending&#x27;) &#123;</span><br><span class="line">      self.status = &#x27;fullfilled&#x27;</span><br><span class="line">      self.value = value</span><br><span class="line">      self.onResolved.map((fn) =&gt; fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line">    if (self.status === &#x27;pending&#x27;) &#123;</span><br><span class="line">      self.status = &#x27;rejected&#x27;</span><br><span class="line">      self.reason = reason</span><br><span class="line">      self.onRejected.map((fn) =&gt; fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    // 会传2个参数（函数）</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function (onFullfilled, onRejected) &#123;</span><br><span class="line">  let self = this</span><br><span class="line">  let promise2</span><br><span class="line"></span><br><span class="line">  onFullfilled =</span><br><span class="line">    typeof onFullfilled === &#x27;function&#x27; ? onFullfilled : function () &#123;&#125;</span><br><span class="line">  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  if (self.status === &#x27;fullfilled&#x27;) &#123;</span><br><span class="line">    return (promise2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">      // 异步调用</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x = onFullfilled(self.value)</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  if (self.status === &#x27;rejected&#x27;) &#123;</span><br><span class="line">    return (promise2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x = onRejected(self.reason)</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  if (self.status === &#x27;pending&#x27;) &#123;</span><br><span class="line">    return (promise2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">      self.onResolved.push(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x = onFullfilled(self.value)</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejected.push(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x = onRejected(self.reason)</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回值不可预估， resolvePromise负责把各种稀奇古怪的 x 包装成一个正常的Promise</span><br><span class="line">  function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    if (promise2 === x) &#123;</span><br><span class="line">      return reject(new TypeError(&#x27;Chaining cycle detected for promise!&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">    if (x instanceof Promise) &#123;</span><br><span class="line">      x.then(</span><br><span class="line">        function (data) &#123;</span><br><span class="line">          resolve(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        function (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (x !== null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        var then = x.then</span><br><span class="line">        var called</span><br><span class="line">        if (typeof then === &#x27;function&#x27;) &#123;</span><br><span class="line">          then.call(</span><br><span class="line">            x,</span><br><span class="line">            (y) =&gt; &#123;</span><br><span class="line">              if (called) &#123;</span><br><span class="line">                return</span><br><span class="line">              &#125;</span><br><span class="line">              called = true</span><br><span class="line">              return resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">            &#125;,</span><br><span class="line">            (r) =&gt; &#123;</span><br><span class="line">              if (called) &#123;</span><br><span class="line">                return</span><br><span class="line">              &#125;</span><br><span class="line">              called = true</span><br><span class="line">              return reject(r)</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        if (called) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        return reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://juejin.im/post/5dc383bdf265da4d2d1f6b23#heading-3">可能是目前最易理解的手写 promise</a></li>
</ul>
]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个批量请求函数</title>
    <url>/2021/06/09/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%89%B9%E9%87%8F%E8%AF%B7%E6%B1%82%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>要求如下</p>
</blockquote>
<ol>
<li>要求最大并发数 maxNum;</li>
<li>每当有一个请求返回，就留下一个空位，可以增加新的请求;</li>
<li>所有请求完成后，结果按照 urls 里面的顺序依次打出。</li>
</ol>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这题如果maxNum 为无限大，其实就是在让你实现Promise.all</span></span><br><span class="line"><span class="comment">// 如果是有一个失败就返回 就是Promise.race</span></span><br><span class="line"><span class="function"><span class="title">multiRequest</span>(<span class="params">urls, maxNum</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">multiRequest</span>(<span class="params">urls = [], maxNum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = urls.length</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(total).fill(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 进行到第几个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count &lt; maxNum) &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> current = count++</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= total) &#123;</span><br><span class="line">          !result.includes(<span class="literal">false</span>) &amp;&amp; resolve(result)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fetch(urls[current]).finally(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          result[current] = res</span><br><span class="line">          <span class="keyword">if</span> (current &lt; total) &#123;</span><br><span class="line">            next()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/378">第 153 题：实现一个批量请求函数</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序代码分析</title>
    <url>/2018/10/23/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="直接插入排序-JavaScript-实现代码："><a href="#直接插入排序-JavaScript-实现代码：" class="headerlink" title="直接插入排序 JavaScript 实现代码："></a>直接插入排序 JavaScript 实现代码：</h3><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//自定义函数，交换i和j的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = array[i]</span><br><span class="line">    array[i] = array[j]</span><br><span class="line">    array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> length = array.length,</span><br><span class="line">    i, <span class="comment">//从第二项开始，与前一项作比较</span></span><br><span class="line">    j <span class="comment">//为了往前进行比较</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="comment">//从第j项开始，与前一项比较大小，如果前项大于后项，则交换位置；如果前项小于等于后项，说明当前排序完成，跳出当前循环，i++进行下一项比较，直到最后一项。</span></span><br><span class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">        swap(array, j - <span class="number">1</span>, j)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接插入排序-JavaScript-实现代码，减少交换次数："><a href="#直接插入排序-JavaScript-实现代码，减少交换次数：" class="headerlink" title="直接插入排序 JavaScript 实现代码，减少交换次数："></a>直接插入排序 JavaScript 实现代码，减少交换次数：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = array.length,</span><br><span class="line">    i,</span><br><span class="line">    j,</span><br><span class="line">    temp <span class="comment">//为了临时保存arr[i]</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    temp = array[i] <span class="comment">//因为如果前一项比后一项大，则前一项要移到后一项，会覆盖第项的值，直到第j项时，j-1小于等于第j项，说明之前第i项的顺序在第j项</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">        array[j] = array[j - <span class="number">1</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        array[j] = temp</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接插入排序-JavaScript-实现代码，二分查找排序"><a href="#直接插入排序-JavaScript-实现代码，二分查找排序" class="headerlink" title="直接插入排序 JavaScript 实现代码，二分查找排序"></a>直接插入排序 JavaScript 实现代码，二分查找排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort2</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, start, end, temp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> middle</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      <span class="comment">//向下取整，获得中间的坐标</span></span><br><span class="line">      middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">if</span> (array[middle] &lt; temp) &#123;</span><br><span class="line">        <span class="comment">//说明temp在middle坐标后</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= array[middle + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">//说明第middle+1项刚大于middle项，返回middle+1</span></span><br><span class="line">          <span class="keyword">return</span> middle + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//范围减1，再次进行while循环，直到找到temp顺序位置</span></span><br><span class="line">          start = middle + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//说明temp的顺序位置在middle之前</span></span><br><span class="line">        <span class="keyword">if</span> (end === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//使用==的都使用===</span></span><br><span class="line">          <span class="comment">//说明temp最小</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//从0-middle开始找</span></span><br><span class="line">          end = middle</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">binarySort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length,</span><br><span class="line">      i,</span><br><span class="line">      j,</span><br><span class="line">      k,</span><br><span class="line">      temp</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">      temp = array[i]</span><br><span class="line">      <span class="keyword">if</span> (array[i - <span class="number">1</span>] &lt;= temp) &#123;</span><br><span class="line">        <span class="comment">//前一项刚好小于等于第i项，不用再进行排序</span></span><br><span class="line">        k = i</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//进行二分查找</span></span><br><span class="line">        k = binarySearch(array, <span class="number">0</span>, i - <span class="number">1</span>, temp)</span><br><span class="line">        <span class="comment">//找到temp的坐标k，将坐标后的都往后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; k; j--) &#123;</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      array[k] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binarySort(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/">常见排序算法 - 插入排序 (Insertion Sort)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22745278">为什么推荐使用 === 不推荐 ==</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>插槽slot</title>
    <url>/2019/04/16/%E6%8F%92%E6%A7%BDslot/</url>
    <content><![CDATA[<p>slot 将父组件的内容传给子组件，弥补视图缺失</p>
<span id="more"></span>

<h1 id="插槽的用法"><a href="#插槽的用法" class="headerlink" title="插槽的用法"></a>插槽的用法</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;slot&gt;如果父组件没有插入内容，就默认出现这个&lt;/slot&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">    `</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h1><p>倘若我们需要多个插槽，我们可以给插槽一个 name 属性，一个不带 name 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><p>让插槽内容能够访问子组件中才有的数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span> &#123;&#123;xxx.text&#125;&#125; <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params">createElement</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> createElement(</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;div&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$scopedSlots.default(&#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">text</span>: <span class="string">&#x27;xxx&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">      )</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="访问-slot-里的内容"><a href="#访问-slot-里的内容" class="headerlink" title="访问 slot 里的内容"></a>访问 slot 里的内容</h1><p>通过 this.$slots 访问静态插槽的内容，得到的是一个 VNodes 数组</p>
<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamic-component-demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;tab in tabs&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">&quot;tab&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#x27;tab-button&#x27;, &#123; active: currentTab === tab &#125;]&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:click</span>=<span class="string">&quot;currentTab = tab&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; tab &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;tab-home&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Home component&lt;/div&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;tab-posts&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Posts component&lt;/div&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;tab-archive&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Archive component&lt;/div&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#dynamic-component-demo&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">currentTab</span>: <span class="string">&#x27;Home&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">tabs</span>: [<span class="string">&#x27;Home&#x27;</span>, <span class="string">&#x27;Posts&#x27;</span>, <span class="string">&#x27;Archive&#x27;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">currentTabComponent</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">&#x27;tab-&#x27;</span> + <span class="built_in">this</span>.currentTab.toLowerCase()</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟继承</title>
    <url>/2019/03/08/%E6%A8%A1%E6%8B%9F%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>在 ES6 出现之前，JS 中是没有类的概念的，只是通过对象模拟类，因此继承也只是模拟继承。</p>
<span id="more"></span>

<h1 id="利用原型链的继承"><a href="#利用原型链的继承" class="headerlink" title="利用原型链的继承"></a>利用原型链的继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;跑&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Human.call(<span class="built_in">this</span>, name) <span class="comment">// 步骤1</span></span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2</span></span><br><span class="line"><span class="comment">// 相当于 Man.prototype.__proto__ = Human.prototype</span></span><br><span class="line"><span class="comment">// 通过new间接更改__proto__</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ES5 中Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</span></span><br><span class="line"><span class="comment">// Man.prototype  = Object.create(Human.prototype, &#123;</span></span><br><span class="line"><span class="comment">//   constructor: &#123;</span></span><br><span class="line"><span class="comment">//     value: Man,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     writable: true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f.prototype = Human.prototype</span><br><span class="line">Man.prototype = <span class="keyword">new</span> f()</span><br><span class="line"></span><br><span class="line">Man.prototype.fight = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;打人&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ES6-中类的继承"><a href="#ES6-中类的继承" class="headerlink" title="ES6 中类的继承"></a>ES6 中类的继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huamn</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;跑&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过关键字extends</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name) <span class="comment">// 调用父类的constructor，实现属性继承</span></span><br><span class="line">    <span class="built_in">this</span>.gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">fight</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打人&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 class 的继承并没有改变 js 的基于原型链继承的方式，只是将展现形式往 java 靠。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>原型链继承的方式复杂，但是能清楚知道是怎么实现的。</li>
<li>ES6 的 class 语法糖，实现方式简单，但并不能直观显示其过程，而且不能通过 <code>Person.prototyoe.xxx = xxx</code> 字面量的方式增加方法</li>
</ol>
]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>继承</tag>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 JavaScript 解构赋值语法</title>
    <url>/2019/06/03/%E6%B5%85%E8%B0%88%20JavaScript%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>最近工作项目中，使用了解构赋值语法，感觉非常爽，但是有些写法只是有印象，每次都要查一下，非常麻烦，故写这篇博客巩固一下知识。</p>
<span id="more"></span>

<p>什么是解构赋值？MDN 上是这么描述的:</p>
<blockquote>
<p>解构赋值语法是一种 Javascript 表达式，它使得将值从数组，或属性从对象，提取到不同的变量中，成为可能。</p>
</blockquote>
<h1 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h1><h2 id="变量声明并赋值时的解构"><a href="#变量声明并赋值时的解构" class="headerlink" title="变量声明并赋值时的解构"></a>变量声明并赋值时的解构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = foo</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="变量先声明后赋值时的解构"><a href="#变量先声明后赋值时的解构" class="headerlink" title="变量先声明后赋值时的解构"></a>变量先声明后赋值时的解构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b</span><br><span class="line">;[a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b</span><br><span class="line">;[a = <span class="number">1</span>, b = <span class="number">2</span>] = [<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h2><p>在 ES6 之前交换变量都需要一个临时变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = ((<span class="number">2</span>)[(a, b)] = [b, a])</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="忽略某些返回值"><a href="#忽略某些返回值" class="headerlink" title="忽略某些返回值"></a>忽略某些返回值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, , b] = f()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="将剩余数组赋值给一个变量"><a href="#将剩余数组赋值给一个变量" class="headerlink" title="将剩余数组赋值给一个变量"></a>将剩余数组赋值给一个变量</h2><p>注意剩余元素必须是最后一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h1><h2 id="基本赋值"><a href="#基本赋值" class="headerlink" title="基本赋值"></a>基本赋值</h2><p>和数组类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">var</span> &#123; p, q &#125; = o</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(q) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="无声明赋值"><a href="#无声明赋值" class="headerlink" title="无声明赋值"></a>无声明赋值</h2><p>和数组的类似，经常在项目中获取数据时用到。<code>&#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code> 不是有效的独立语法，因为左边的<code> &#123;a, b&#125;</code> 被认为是一个块而不是对象字面量。<code>(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;) </code>是有效的，正如 <code>var &#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code></p>
<h2 id="给新的变量名赋值"><a href="#给新的变量名赋值" class="headerlink" title="给新的变量名赋值"></a>给新的变量名赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">p</span>: foo, <span class="attr">q</span>: bar &#125; = o</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; a = <span class="number">10</span>, b = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="给新的变量命名并提供默认值"><a href="#给新的变量命名并提供默认值" class="headerlink" title="给新的变量命名并提供默认值"></a>给新的变量命名并提供默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(aa) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(bb) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawES2015Chart</span>(<span class="params">&#123; size = <span class="string">&#x27;big&#x27;</span>, cords = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;, radius = <span class="number">25</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(size, cords, radius)</span><br><span class="line">  <span class="comment">// do some chart drawing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawES2015Chart(&#123;</span><br><span class="line">  <span class="attr">cords</span>: &#123; <span class="attr">x</span>: <span class="number">18</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">30</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="从作为函数实参的对象中提取数据"><a href="#从作为函数实参的对象中提取数据" class="headerlink" title="从作为函数实参的对象中提取数据"></a>从作为函数实参的对象中提取数据</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userId</span>(<span class="params">&#123; id &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whois</span>(<span class="params">&#123; displayName: displayName, fullName: &#123; firstName: name &#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(displayName + <span class="string">&#x27; is &#x27;</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">displayName</span>: <span class="string">&#x27;jdoe&#x27;</span>,</span><br><span class="line">  <span class="attr">fullName</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;userId: &#x27;</span> + userId(user)) <span class="comment">// &quot;userId: 42&quot;</span></span><br><span class="line">whois(user) <span class="comment">// &quot;jdoe is John&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象属性计算名和解构"><a href="#对象属性计算名和解构" class="headerlink" title="对象属性计算名和解构"></a>对象属性计算名和解构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">let</span> &#123; [key]: foo &#125; = &#123; <span class="attr">z</span>: <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值语</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历和广度优先遍历</title>
    <url>/2021/06/18/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>用 JavaScript 实现深度优先遍历和广度优先遍历</p>
<span id="more"></span>

<p>首先得了解什么是实现深度优先遍历和广度优先遍历。</p>
<p>深度优先遍历 DFS 是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<p>广度优先遍历 BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</p>
<p>以下是代码</p>
<p>深度优先遍历:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nodes = []</span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    stack.push(node)</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> item = stack.pop() <span class="comment">// 取最后面一个</span></span><br><span class="line">      nodes.push(item)</span><br><span class="line">      <span class="keyword">const</span> &#123; children &#125; = item</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = children.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        stack.push(children[index])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广度优先遍历:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nodes = []</span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    stack.push(node)</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> item = stack.shift() <span class="comment">// 取最第一个</span></span><br><span class="line">      nodes.push(item)</span><br><span class="line">      <span class="built_in">Array</span>.prototype.slice.call(item.children).forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        stack.push(v)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 await</title>
    <url>/2021/06/08/%E7%90%86%E8%A7%A3%20await/</url>
    <content><![CDATA[<p>输出以下代码执行结果</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">10</span> * <span class="number">1000</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time()</span><br><span class="line">  <span class="keyword">const</span> x = wait()</span><br><span class="line">  <span class="keyword">const</span> y = wait()</span><br><span class="line">  <span class="keyword">const</span> z = wait()</span><br><span class="line">  <span class="keyword">await</span> x</span><br><span class="line">  <span class="keyword">await</span> y</span><br><span class="line">  <span class="keyword">await</span> z</span><br><span class="line">  <span class="built_in">console</span>.timeEnd()</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>当执行到 <code>console.time();</code> 时，后面三句代码是同步的，因此会依次执行 <code>wait()</code> 里的代码，当执行到后面的 <code>await x</code> 时，10 秒后执行 <code>await y</code>，此时 x 、 y 也结束了。因同步任务也会耗时，故输出结果会比 10000ms 多一点。</p>
<p>..脑筋急转弯呢</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/251">第 129 题：输出以下代码执行结果</a></li>
</ul>
]]></content>
      <tags>
        <tag>await</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实现一个发布订阅模式和观察者模式</title>
    <url>/2020/09/01/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>补习一下发布订阅模式和观察者模式，比较两者区别</p>
<span id="more"></span>

<p>创建一个发布订阅模式 eventBus ，eventBus 有 events 属性，on，emit，off 等方法;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> eventBus = &#123;</span><br><span class="line">  <span class="attr">events</span>: <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">event, data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> eventSet = <span class="built_in">this</span>.events.get(event)</span><br><span class="line">    <span class="keyword">if</span> (eventSet) &#123;</span><br><span class="line">      eventSet.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        effect(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">event, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> eventSet = <span class="built_in">this</span>.events.get(event)</span><br><span class="line">    <span class="keyword">if</span> (!eventSet) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events.set(event, (eventSet = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    eventSet.add(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>.events.delete(event)</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;删除失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">eventBus.on(<span class="string">&#x27;xxx&#x27;</span>, <span class="function"><span class="params">xxx</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xxx)</span><br><span class="line">&#125;)</span><br><span class="line">eventBus.emit(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>创建一个观察者模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = &#123;</span><br><span class="line">  <span class="attr">events</span>: <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events.add(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">subject.on(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">subject.emit()</span><br></pre></td></tr></table></figure>

<p>发布订阅模式比观察者模式多了一层，能选择发布哪一些事件内容，而观察者只能触发所有事件内容。</p>
]]></content>
      <tags>
        <tag>发布订阅</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的模块管理器</title>
    <url>/2020/11/10/%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>双 11 的销售额不会自己增长，知识也是，需要时长充电。最近在看 <code>你不知道的 JavaScript</code>，里面讲了模块管理器的核心概念，梳理一下其思路。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> modules = &#123;&#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  name：定义的模块名称；</span></span><br><span class="line"><span class="comment">  deps：依赖的模块；</span></span><br><span class="line"><span class="comment">  impl：执行函数。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 保存 modules 中对应的 module。</span></span><br><span class="line">      deps[i] = modules[deps[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存定义的模块，并将上面保存依赖模块传入到执行函数中，注意此处使用的是apply，参数是以数组的形式传入的，依次对应传入的 deps 顺序。</span></span><br><span class="line">    modules[name] = impl.apply(impl, deps)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> modules[name]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">define</span>: define,</span><br><span class="line">    <span class="attr">get</span>: get</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">MyModules.define(<span class="string">&#x27;bar&#x27;</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Let me introduce: &#x27;</span> + who</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">hello</span>: hello &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">MyModules.define(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;bar&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hungry = <span class="string">&#x27;hippo&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">awesome</span>: awesome</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = MyModules.get(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> foo = MyModules.get(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.hello(<span class="string">&#x27;hippo&#x27;</span>))</span><br><span class="line"><span class="comment">// Let me introduce: hippo</span></span><br><span class="line">foo.awesome()</span><br><span class="line"><span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>

<p>上面函数符合模块模式的两个必要条件：</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
]]></content>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>造轮子时踩的坑</title>
    <url>/2019/04/09/%E9%80%A0%E8%BD%AE%E5%AD%90%E6%97%B6%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="Vue-相关"><a href="#Vue-相关" class="headerlink" title="Vue 相关"></a>Vue 相关</h1><ol>
<li>v-if：没有在 dom 中出现。v-show ：元素被加上 <code>display:none</code></li>
<li>scss 尽量都用变量 <code>$</code></li>
<li>使用 prop 传 Boolean 值时，需要在所传属性前加<code>:</code></li>
<li>需要获取组件的 <code>$refs</code> 值时，需要在 <code>mounted</code> 后才能获取，mounted 是异步的</li>
<li>slot 不能直接出现在 template 中，会报错</li>
<li>$children 子组件</li>
<li>声明组件后，再设置 name，方便调试</li>
<li>scoped 会隔绝其他组件的样式，建议使用</li>
<li>Vue 的<a href="https://jsbin.com/bipojipeho/edit?html,output">双向绑定</a>，实质上是：</li>
</ol>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;button @click=<span class="string">&quot;message++&quot;</span>&gt;+&lt;<span class="regexp">/button&gt;&lt;/</span>p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message=$event.target.value&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>computed 的属性会被缓存</li>
<li>prop 的 default 属性如果是对象就用函数返回，否者页面有多个相同组件时，改对象的数据会被共享</li>
<li><a href="https://jsbin.com/jaxehabogu/1/edit?html,console,output">.sync</a>(类似 prop 的双向绑定) 实质上是：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;xxx&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;child @update:title=&quot;value =&gt; xxx=value&quot;  :title= &quot;xxx&quot;&gt;&lt;/child&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title.sync</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;child&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">template</span>:<span class="string">`&lt;div&gt;&#123;&#123;newTitle&#125;&#125;&lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">newTitle</span>:<span class="built_in">this</span>.title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">     <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.newTitle +=<span class="number">1</span></span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, <span class="built_in">this</span>.newTitle)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">xxx</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>props 需要用户传值，data 是内部自身维护的</li>
<li>xxx.bind() 会生成新函数</li>
<li>不要在多个地方操作数据，保证数据单向流通</li>
</ol>
<h1 id="规范相关"><a href="#规范相关" class="headerlink" title="规范相关"></a>规范相关</h1><ol>
<li>提交代码时，变更记录写详细，方便以后查阅</li>
<li>遵循用例-UI-代码-测试的开发流程</li>
<li>函数不要超 5 行</li>
</ol>
<h1 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h1><ol>
<li>安装开发者使用的库：<code>npm i xxx -D</code></li>
<li>npm 不能用的时候，就用 yarn</li>
</ol>
<h1 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h1><ol>
<li>本应出现的值没有出现，试试 setTimeout 或者$nextTick</li>
<li>测试时先错一次</li>
<li>css 要渲染到页面上才能取到值</li>
<li>每次测试结束，dom.remove(),vm.$destroy()</li>
</ol>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>重排和重绘</title>
    <url>/2020/07/28/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<p>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。</p>
<span id="more"></span>

<p>以下三种情况，会导致网页重新渲染。</p>
<ul>
<li>修改 DOM</li>
<li>修改样式表</li>
<li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li>
</ul>
<p>重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。</p>
<p>需要注意的是，”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。</p>
<p>有一些技巧，可以降低浏览器重新渲染的频率和成本。</p>
<ol>
<li>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作；</li>
<li>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排；</li>
<li>不要一条条地改变样式，而要通过改变 class，或者 csstext 属性，一次性地改变样式；</li>
<li>尽量使用离线 DOM，而不是真实的网面 DOM，来改变元素样式。比如，操作 Document Fragment 对象，完成后再把这个对象加入 DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点；</li>
<li>先将元素设为 display: none（需要 1 次重排和重绘），然后对这个节点进行 100 次操作，最后再恢复显示（需要 1 次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达 100 次的重新渲染；</li>
<li>position 属性为 absolute 或 fixed 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响；</li>
<li>只在必要的时候，才将元素的 display 属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重绘有影响，不影响重排；</li>
<li>使用虚拟 DOM 的脚本库，比如 React，Vue 等；</li>
<li>使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染。</li>
</ol>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">网页性能管理详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2019/01/19/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>今天我们搞清楚闭包是什么。</p>
<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>MDN 就是简单的一句话：</p>
<blockquote>
<p>A closure is the combination of a function and the lexical environment within which that function was declared.</p>
</blockquote>
<p>翻译过来就是：闭包是函数和该函数内部能访问到的<strong>环境</strong>变量的总和。</p>
<span id="more"></span>

<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Mozilla&#x27;</span> <span class="comment">// name是 init 创建的局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// displayName() 是一个内部函数，闭包</span></span><br><span class="line">    alert(name) <span class="comment">// 使用了父函数申明的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  displayName()</span><br><span class="line">&#125;</span><br><span class="line">init()</span><br></pre></td></tr></table></figure>

<p><code>init()</code> 函数创建了局部变量 <code>name</code> 和函数 <code>displayName()</code> 函数。<code>displayName()</code> 函数是一个定义在 <code>init()</code>函数内部的函数，并且只能在<code>init()</code>函数内部可用。<code>displayName()</code> 函数没有自己的局部变量。但是是因为内部函数有权访问外部函数的变量，所以 <code>displayName()</code> 可以使用父函数定义的变量 <code>name</code> 。但如果 <code>displayName()</code> 中也有相同的变量，则会使用内部定义的变量。</p>
<p>这个环境包含了这个闭包<strong>创建时</strong>所能访问的<strong>所有</strong>局部变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>)) <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>上面的这个例子中函数 <code>makeAdder()</code> 将闭包函数 return，以供使用。 <code>add5</code> 和 <code>add10</code> 都是闭包。他们共享了相同函数的定义，但是保存了不同的环境。在 <code>add5</code> 中 <code>x</code> 为 5，在 <code>add10</code> 中， <code>x</code> 则为 10。</p>
<h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><p>闭包常常用来“间接访问一个变量”。换句话说，“隐藏一个变量”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()) <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter.increment()</span><br><span class="line">Counter.increment()</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()) <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter.decrement()</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()) <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure>

<p>该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。</p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;help&quot;</span>&gt;</span>Helpful notes will appear here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;email&#x27;</span>, <span class="attr">help</span>: <span class="string">&#x27;Your e-mail address&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;name&#x27;</span>, <span class="attr">help</span>: <span class="string">&#x27;Your full name&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;age&#x27;</span>, <span class="attr">help</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i]</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   for (let i = 0; i &lt; helpText.length; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   var item = helpText[i];</span></span><br><span class="line">  <span class="comment">//   document.getElementById(item.id).onfocus = function() &#123;</span></span><br><span class="line">  <span class="comment">//     showHelp(item.help);</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;//使用let而不是var，每个闭包都绑定了块作用域的变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp()</span><br></pre></td></tr></table></figure>

<p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的 input 的 ID。通过循环这三项定义，依次为相应 input 添加了一个 onfocus 事件处理函数，以便显示帮助信息。</p>
<p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个 input 上，显示的都是关于年龄的信息。</p>
<p>原因是赋值给 onfocus 的是闭包。这些闭包是由他们的函数定义和在 setupHelp 作用域中捕获的环境所组成的。这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量 item。当 onfocus 的回调执行时，item.help 的值被决定。由于循环在事件触发之前早已执行完毕，变量对象 item（被三个闭包所共享）已经指向了 helpText 的最后一项。</p>
<blockquote>
<p>引用</p>
</blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
</search>
