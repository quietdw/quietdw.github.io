---
title: 正则表达式
tags:
  - 正则
  - RegExp
---

正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。

<!-- more -->

# 创建一个正则表达式

1. 使用一个正则表达式字面量，其由包含在斜杠之间的模式组成。形如：

```javascript
const regex = /pattern/ flags
```

2. 调用RegExp对象的构造函数。形如：

```javascript
var re = new RegExp(pattern, flags);
```

pattern 部分可以是任何简单或者复杂的正则表达式，每个正则表达式又可带一个或多个标志 （flag），用以标明正则表达式的行为。
    - g：表示全局模式，即模式将被应用于所有字符串，而不是在遇到第一个匹配项就立即停止；
    - i：不区分大小写；
    - m：表示多行，会影响 `^` , `$` 的行为。

第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。

# 实例属性

## RegExp.prototype.ignoreCase

返回一个布尔值，表示是否设置了i修饰符。

## RegExp.prototype.global

返回一个布尔值，表示是否设置了g修饰符。

## RegExp.prototype.multiline

返回一个布尔值，表示是否设置了m修饰符。

## RegExp.prototype.lastIndex

返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义。lastIndex属性只对同一个正则表达式有效。

```
var count = 0;
while (/a/g.test('babaa')) count++;
```

上面代码会导致无限循环，因为while循环的每次匹配条件都是一个新的正则表达式，导致lastIndex属性总是等于0。

## RegExp.prototype.source

返回正则表达式的字符串形式（不包括反斜杠），该属性只读。

# 实例方法

## RegExp.prototype.test()

正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。

```javascript
/cat/.test('cats and dogs') // true
```

如果带有g修饰符，则会从上一次结束的位置开始向后匹配

```javascript
var r = /x/g;
var s = '_x_x';

r.lastIndex // 0
r.test(s) // true

r.lastIndex // 2
r.test(s) // true

r.lastIndex // 4
r.test(s) // false
```

## RegExp.prototype.exec()

正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。

如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。

如果正则表达式加上`g`修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。

利用`g`修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。

# 字符串的实例方法

## String.prototype.match()

与exec类似，但是如果有`g`修饰符，则返回全部匹配结果。

## String.prototype.search()

字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。

## String.prototype.replace()

字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

`replace()` 的应用，消除首位的空格

```javascript
var str = '  #id div.class  ';

str.replace(/^\s+|\s+$/g, '')
// "#id div.class"
```

replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。

- $&：匹配的子字符串。
- $`：匹配结果前面的文本。
- $'：匹配结果后面的文本。
- $n：匹配成功的第n组内容，n是从1开始的自然数。
- $$：指代美元符号$。

```javascript
'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
// "world hello"
```

第二个参数可以是一个函数，将每一个匹配内容替换为函数返回值。

## String.prototype.split()

字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。

# 匹配规则

## 字面量字符和元字符

字面量字符，简单的匹配，比如 `/a/` 匹配a，某个字符只表示它字面的含义。还有一部分字符有特殊含义，不代表字面的意思，它们叫做“元字符”（metacharacters），主要有以下几个。

### 点字符

点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。注意，对于码点大于0xFFFF字符，点字符不能正确匹配，会认为这是两个字符。

### 位置字符

`^` 表示字符串的开始位置，`$` 表示字符串的结束位置.

### 选择符

竖线符号（`|`）在正则表达式中表示“或关系”（OR），即`cat|dog`表示匹配cat或dog。选择符会包括它前后的多个字符，比如`/ab|cd/`指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。

```javascript
/a(\s+|\t)b/.test('a\tb') // true 匹配a,b 之间有空格或者制表符
```

## 转义符

正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成\+。

## 特殊字符

正则表达式对一些不能打印的特殊字符，提供了表达方法。

- \cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。
- [\b] 匹配退格键(U+0008)，不要与\b混淆。
- \n 匹配换行键。
- \r 匹配回车键。
- \t 匹配制表符 tab（U+0009）。
- \v 匹配垂直制表符（U+000B）。
- \f 匹配换页符（U+000C）。
- \0 匹配null字符（U+0000）。
- \xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。
- \uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。

## 字符类

字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。

### 脱字符（^）

如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。

如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。

脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

### 连字符

某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义。

连字符还可以用来指定 Unicode 字符的范围。

## 预定义模式

- \d 匹配0-9之间的任一数字，相当于[0-9]。
- \D 匹配所有0-9以外的字符，相当于[^0-9]。
- \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
- \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
- \s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。
- \S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。
- \b 匹配词的边界。
- \B 匹配非词边界，即在词的内部。

## 重复类

模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。

## 量词符

量词符用来设定某个模式出现的次数。

- ? 问号表示某个模式出现0次或1次，等同于{0, 1}。
- * 星号表示某个模式出现0次或多次，等同于{0,}。
- + 加号表示某个模式出现1次或多次，等同于{1,}。

## 贪婪模式

默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。

```javascript
var s = 'aaa';
s.match(/a+?/) // ["a"]
```

## 组匹配

正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。

正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。

```javascript
/(.)b(.)\1b\2/.test("abcabc")
// true
```

上面的代码中，\1表示第一个括号匹配的内容（即a），\2表示第二个括号匹配的内容（即c）。

括号还可以嵌套。

```javascript
/y((..)\2)\1/.test('yabababab') // true
// true
```

上面代码中，\1指向外层括号，\2指向内层括号。

### 非捕获组

(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

```javascript
var m = 'abc'.match(/(?:.)b(.)/);
m // ["abc", "c"]
```

上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。

### 先行断言

x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。“先行断言”中，括号里的部分是不会返回的。

### 先行否定断言

x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。

> 引用
- [RegExp 对象](https://wangdoc.com/javascript/stdlib/regexp.html)
