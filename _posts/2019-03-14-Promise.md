---
title: Promise
tags:
  - Promise
---

之前在写 ajax 方面的博客的时候，简单的介绍了一下 Promise 在 ajax 里的应用，这次详细的梳理一下Promise 功能以及原理。

<!-- more -->

# 含义

首先，Promise 是一个对象，也是一个构造函数。Promise 的设计思想是所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。这样可以让异步操作写起来就像在写同步操作的流程，而不必一层层地嵌套回调函数。

```javascrpt

// 传统写法
step1(function (value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // ...
      });
    });
  });
});


// Promise 的写法
var doSomething = new Promise()
doSomething.then('第一件事').then('第二件事')
```

上面的例子如果是用回调函数实现会非常麻烦。

Promise 对象的状态不受外界影响。对象有三个状态，`pending`、`fulfilled`、`rejected`。一旦状态发生改变（pending -> fulfilled,fulfilled-> reject），就不会在变。

Promise 也有缺点，首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

# 基本用法

下面代码创造了一个Promise实例。

```javascript
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value)
  } else {
    reject(error)
  }
})
```

实例生成后，可以用 then 方法指定 resolve 和 reject 的回调函数，then 的第一个参数是成功的回调函数，第二个是失败的回调函数。

Promise 新建后就会立即执行。

```javascript
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```

下面是异步加载图片的例子。

```javascript
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();

    image.onload = function() {
      resolve(image);
    };

    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };

    image.src = url;
  });
}
```

上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。

上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。

调用resolve或reject并不会终结 Promise 的参数函数的执行

```javascript
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1
```

上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务.

# Promise.prototype.then()

Promise 实例具有then方法，也就是说，then方法是定义在原型对象。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因而可以采用链式写法，即then方法后面再调用另一个then方法。

# Promise.prototype.catch()




> 引用
- [Promise 对象](https://wangdoc.com/javascript/async/promise.html)